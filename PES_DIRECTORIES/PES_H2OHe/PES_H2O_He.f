      SUBROUTINE USER_DEFINED_PES(V,R,rvib,rvib2,alpha,beta,gamma,
     &										   aalpha,bbeta,ggamma)
!     INPUT:  R - distance betweenn COMs, rvib - vibrational coordinate
! 		      alpha,beta,gamma - Euler's angles of the first molecule
!   		  aalpha,bbeta, ggamma - Euler's angles of the second molecule
!     OUTPUT: V - value of the potential
      IMPLICIT NONE
      REAL*8 V,R,alpha,beta,gamma,aalpha,bbeta,ggamma,t,rvib,rvib2
      CALL HeH2O_PES_routine(r,beta,gamma,V)
      END SUBROUTINE USER_DEFINED_PES
!----------!
! OPTION 2 !
!----------! 
!	  USE KEYWORD "EXPANSION=YES" TO INITIATE THIS OPTION
      SUBROUTINE USER_DEFINED_TERMS(T,I,R)
!     THIS SUBROTUNE COMPUTES RADIAL COEFFICENTS OF THE PES EXPANSION AT A GIVEN DISTANCE
!     INPUT:  R - distance between COMs of particles, I - TERM NUMBER
!     OUTPUT: T - value of coefficent 	  
      IMPLICIT NONE	  
      REAL*8 T,R
      INTEGER I
!     USER MUST INSERT A CALL OF AN EXTERNAL SUBROUTINE HERE.
!     DELETE THE "STOP" COMMAND BELOW IF THE SUBROUTINE SUPPLIED.
!     IN CASE IF USER FORGOT TO SUPPLY THE SUBTOUITNE,
!     BUT THE MAIN PROGRAM REQUIRES IT, THEN STOP:
      STOP "ERROR: USER_DEFINED_TERMS IS NOT SUPPLIED"
	  END SUBROUTINE USER_DEFINED_TERMS
!----------!
! OPTION 3 !
!----------! 
!	  USE KEYWORDS "EXPANSION=YES, TERMS_FILE=YES" TO INITIATE THIS OPTION
! 	  SIMILAR TO OPTION 2, BUT NO SUBROUTINE IS REQUIRED
!     USER SHOULD PROVIDE THE FILE EXPAN_PES_TERMS.DAT 
!     IN THE MAIN PROGRAM DIRECTORY CONTAINING THE COEFFICEINS 
!     OF POTENTIAL EXPANSION PRECOMPUTED EXTERNALLY.
! 	  SEE EXAMPLE FILES SUPPLIED WITH THE CODE.
!----------!
! OPTION 4 !
!----------! 
!	  USE KEYWORDS "EXPANSION=YES, TERMS_ONFLY=YES" TO INITIATE THIS OPTION
      SUBROUTINE USER_DEFINED_COEFFS(T,DTDR,I,R) 
!     THIS SUBROUTINE COMPUTES RADIAL COEFFICENTS OF THE PES EXPANSION 
!     AND THEIR DERIVATIVES AT A GIVEN DISTANCE R
      IMPLICIT NONE
!     INPUT : R - distance between COMs of particles, I - TERM NUMBER
!     OUTPUT: T - value of coefficent, DTDR - its radial derivative 	  
      REAL*8 T,R,DTDR 
      INTEGER I
!     USER MUST INCERT A CALL OF AN EXTERNAL SUBROUTINE HERE.
!     DELETE THE "STOP" COMMAND BELOW IF THE SUBROUTINE IS SUPPLIED.
!     IN CASE IF USER FORGOT TO SUPPLY THE SUBTOUITNE,
!     BUT THE MAIN PROGRAM REQUIRES IT, THEN STOP:	
      STOP "ERROR: USER_DEFINED_COEFFS IS NOT SUPPLIED"
      END SUBROUTINE USER_DEFINED_COEFFS 
      MODULE INITIALISATION
	  LOGICAL :: INI_DONE = .TRUE.
      END MODULE INITIALISATION
	  SUBROUTINE HeH2O_PES_routine(r_inp,beta_inp,gamma_inp,V_out)
      USE INITIALISATION	  
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MXDIM = 400000)
      PARAMETER(MXM=20,NCCM=300,NLEVM=500)
      CHARACTER*1 CHAR
      CHARACTER*64 NAME1,NAME2,NAME3
      DIMENSION LAMD(2*MXM),PD(MXM),PR(MXM,NCCM)
      DIMENSION RT(NCCM)
      DIMENSION COUPL(2*MXM,NLEVM,NLEVM)
      DIMENSION ELEM(NCCM,NLEVM,NLEVM)
      DIMENSION JC(NLEVM),ITAUC(NLEVM),JR(NLEVM),ITAUR(NLEVM)
      DIMENSION X(MXDIM)
      COMMON/ANGLES/COSANG(7),FACTOR,IHOMO,ICNSYM,IHOMO2,ICNSY2
      COMMON /MEMORY/ MX,IXNEXT,NIPR,IVLFL,X
      DATA RSTART/1.0D0/, DR/0.1D0/, NCC/110/
      IF(INI_DONE)	  THEN
      IXNEXT = 1
      NIPR = 2
      MX = MXDIM
      ICHAR = 1
      WRITE(CHAR,'(i1)')ICHAR
!   PREMIER APPEL D'INITIALISATION
      ITYPE=6
      MXL=2*MXM
      ICNT= -1
      CALL POTENL(ICNT,MXL,MPOT,LAMD,RR,PD,ITYPE)
!c open file with couplings

       NAME1 = 'PES_H2OHe/coupling-is'//char(1:1)//'.txt'
       OPEN(20,FILE=NAME1)
       read(20,*)mxlam,nlev

       if(mxlam.ne.mxl) stop 'error mxlam'
       
       do ll = 1, mxlam
       do icc = 1, nlev
        do irr = 1, icc
 
        read(20,*)LI,LM,MU,IC,JC(icc),ITAUC(icc),
     &        IR,JR(irr),ITAUR(irr),
     &          coupl(ll,icc,irr)

        if(icc.ne.ic) stop 'error IC'
        if(irr.ne.ir) stop 'error IR'
        
        if(LM.ne.LAMD(2*LI-1))then
        write(*,*)'  LL',LL,'  LI',LI,'  LM',LM,
     &     'LAMD(2*LI-1)',LAMD(2*LI-1)
        stop 'error LM'
        endif
        if(MU.ne.LAMD(2*LI))stop 'error MU'


       enddo
       enddo
       enddo
       close(20)

!  EVALUATION OF POTENTIAL

      DO I=1,NCC

      
      RT(I)=RSTART + DR*DFLOAT(I-1)      
      RR=RT(I)

 


       ENDDO
       INI_DONE = .FALSE.
       ENDIF 
       iaa=1
! re-build PES from Coefficients and by direct call to subroutine
!       OPEN(30,STATUS='UNKNOWN',FILE='verif.out')
       PI = ACOS(-1.D0)
       CC = 1.D0/DSQRT(2.D0*PI)


!       DO IR = 1, NCC
       RR  = r_inp
       
       THETA = beta_inp*180.D0/PI
 !      DO ITH = 1, 5
!
        PHI = gamma_inp*180.D0/PI
        COSANG = COS(PI*THETA/180.D0)
 !       DO IPHI = 1,3 

        PHIPI = PI*PHI/180.D0
        
        
        CALL arh2osapt(iaa,rr,theta,phi,ener)
        V_out = ener
  
!        WRITE(30,
!     &'(e17.10,1x,e17.10,1x,e17.10,1x,e17.10)')
!     & RR,THETA,PHI,ENER   
       
!       PHI = PHI + 45.D0
!       ENDDO
!       THETA = THETA + 45.d0
!       ENDDO
!       ENDDO
       
!       CLOSE(30)

        END


      SUBROUTINE POTENL(ICNTRL, MXLMB, MPOTL, LAM, R, P, ITYP)
C
C     -----------------------------------------------------------------
C    * MOLSCAT GENERAL POTENL ROUTINE; DESCRIPTION OF FUNCTIONS:
C     -----------------------------------------------------------------
C     VERSION 14 IMPLEMENTS THREE OPTIONS FOR DESCRIBING THE POT'L
C       1. POT'L EXPANDED IN ANGULAR FUNCTIONS - SYMMETRIES DESCRIBED
C          BY MXLAM,LAMBDA INPUT, RADIAL COEFFS DESCRIBED BY INPUT
C          POWERS AND EXPONENTIALS *OR* VSTAR MECHANISM.
C          THIS IS THE ORIGINAL MOLSCAT OPTION.
C          MXLAM.GT.0 MUST BE INPUT AND LVRTP MUST BE .FALSE. (DEFAULT)
C       2. POT'L EXPANDED IN ANGULAR FUNCTIONS - PROJECTED VIA VRTP
C          MECHANISM.  SYMMETRIES MAY BE DESCRIBED *EITHER* BY
C          A.) SYMMETRY DESCRIPTIONS INPUT VIA LAMBDA ARRAY
C              MXLAM.GT.0 AND LVRTP=.TRUE. *MUST* BE INPUT
C          B.) SYMMETRY DESCRIPTIONS GENERATED FROM LMAX (MMAX)
C              MXLAM.LE.0 (DEFAULT) AND  LMAX.GE.0 MUST BE INPUT
C          IF BOTH ARE SPECIFIED (MXLAM.GT.0.AND.LMAX.GE.0) LMAX IS
C              IGNORED, I.E., CASE (2-A) TAKES PRECEDENCE
C          ALLOWED ONLY FOR NON-IOS CASES (ITYPE.LT.100)
C       3. POT'L IS NOT EXPANDED IN ANGULAR FUNCTIONS (SUITABLE FOR
C          IOS CALCULATIONS ONLY) AND IS OBTAINED VIA THE VRTP MECHANISM
C          MXLAM.LE.0 MUST BE SPECIFIED (AND ITYPE.GT.100 IN &BASIS)
C
C     -----------------------------------------------------------------
C    * NOTES ON HISTORY OF ROUTINE:
C     -----------------------------------------------------------------
C
C    *INTRODUCES XPT(MXPT,MXDIM), XWT(MXPT,MXDIM), INX(MXDIM),*
C    *    NPTS(MXDIM); NPTS IS IN NAMELIST /BASIN/            *
C    *    TO ALLOW GENERAL, MULTI-DIMENSIONAL PROJECTIONS     *
C    **********************************************************
C     CORRECTIONS 19 OCT 95 AFFECTING PROJECTION OF ITYPE=3 (SG)
C     PROJECTION FOR ITYPE=3 ADDED 20 JUL 94
C     CODE FOR ITYPE=4 ADDED BY SG 30 JUN 94 (FOLLOWING TRP CODE)
C              ITYPE=9 INTERFACE ADDED BY JMH 15 AUG 94
C     PREVIOUS REVISION DATES 1 FEB 1994 (SG); 3 JAN 1994 (JMH).
C     -----------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE LVRTP,ITSAVE,NTERM,NPOWER,A,E,NPT,NPS,NPTS,XPT,XWT,
     1    IXFAC,NDIM
C
C     -----------------------------------------------------------------
C    * NOTES FOR PROGRAMS OTHER THAN MOLSCAT (STORAGE CONSIDERATIONS):
C     -----------------------------------------------------------------
C     THE X() ARRAY CAN BE DEFINED INTERNALLY OR, IF THIS ROUTINE
C       IS USED WITH THE MOLSCAT CODE, IT IS TAKEN FROM THE
C       /MEMORY/...,X()  STORAGE MECHANISM IN MOLSCAT.
C     THIS DECK SHOULD BE MODIFIED ACCORDINGLY IN THE STATEMENTS BELOW
C       AND THE STATEMENTS WHICH FOLLOW STATEMENT NUMBER 2000
C     -----------------------------------------------------------------
C     ----- NEXT TWO STATEMENTS ARE USED FOR INTERNAL X() STORAGE -----
C     ----- ALSO, "X" MUST BE ADDED TO THE "SAVE" STATEMENT ABOVE -----
C     PARAMETER (MXX=30000)
C     DIMENSION X(MXX)
C     ----- NEXT TWO STATEMENTS ARE FOR MOLSCAT /MEMORY/ MECHANISM-----
      DIMENSION X(1)
      COMMON /MEMORY/ MX,IXNEXT,NIPR,IVLFL,X
C
C     -----------------------------------------------------------------
C    * SPECIFICATION STATEMENTS:
C     -----------------------------------------------------------------
C     MXDIM IS MAX NUMBER OF DIMENSIONS FOR PROJECTION
C     MXPT LIMITS POINTS PER DIMENSION FOR PROJECTION
C     MXHERM LIMITS HERMITE POLYNOMIALS FOR VIBRATIONAL PROJECTION
      PARAMETER (MXPT=96, MXDIM=3, MXHERM=20)
C     DIMENSIONS FOR LAMBDA AND POWER/EXPONENTIAL TERMS
      PARAMETER (MXL=360, IXMX=200, IEXMX=200, NPXMX=20)
      INTEGER CFLAG
      LOGICAL QOUT,LVRTP, XLAM,LCALC
      CHARACTER*8 QNAME(10), QTYPE(10)
C     CHARACTER*6 PNAMES
C     DIMENSION PNAMES(25),LOCN(25),INDX(25)
      DIMENSION P(MXLMB), LAM(MXLMB)
      DIMENSION NTERM(MXL),NPOWER(IXMX),NPUNI(NPXMX),LAMBDA(MXL)
      DIMENSION A(IXMX), E(IEXMX)
      DIMENSION H(MXHERM)
      DIMENSION XPT(MXPT,MXDIM),XWT(MXPT,MXDIM),INX(MXDIM),NPTS(MXDIM)
      EQUIVALENCE (NPT,NPTS(1)), (NPS,NPTS(2))
C
      EQUIVALENCE (MXLAM,MXSYM),(LMAX,L1MAX)
      COMMON/NPOT/NPTL
      COMMON/ANGLES/COSANG(7),FACTOR,IHOMO,ICNSYM,IHOMO2,ICNSY2
C
C     -----------------------------------------------------------------
C    * NAMELIST SPECIFICATION (AND DESCRIPTION OF PARAMETERS):
C     -----------------------------------------------------------------
      NAMELIST/POTL/ RM,EPSIL,MXLAM,MXSYM,LAMBDA,NPOTL,NTERM,
     1   A,NPOWER,E,CFLAG,LVRTP,NPT,NPS,
     2   IHOMO,ICNSYM,LMAX,L1MAX,L2MAX,MMAX,IVMIN,IVMAX,
     3   NPTS,IHOMO2,ICNSY2
C     DATA PNAMES/'RM','EPSIL','MXLAM','MXSYM','LAMBDA','NPOTL','NTERM',
C    1   'A','NPOWER','E','CFLAG','LVRTP','NPT','NPS',
C    2   'IHOMO','ICNSYM','LMAX','L1MAX','L2MAX','MMAX','IVMIN','IVMAX',
C    3   'NPTS','IHOMO2','ICNSY2'/
C     DATA INDX/25*0/
C
C     RM     - LENGTH SCALING FACTOR; VALUE IN ANGSTROMS
C     EPSIL  - ENERGY SCALING FACTOR; VALUE IN WAVENUMBERS (1/CM)
C     MXLAM  - NUMBER OF POTENTIAL TERMS RETURNED
C     MXSYM  - A SYNONYM FOR MXLAM, RETAINED FOR COMPATIBILITY
C     LAMBDA - SYMMETRY INDICES FOR POTENTIAL
C     NPOTL  - NO LONGER A RELEVANT INPUT PARAMETER
C     -------- BELOW DESCRIBE TERMS AS EXPONENETIALS/INVERSE POWERS
C     NTERM  - ARRAY: NTERM(I) IS NUMBER OF TERMS CONTRIBUTING TO P(I)
C              NTERM(I) .LT. 0 CALLS VINIT/VSTAR FOR POTENTIAL TERM I
C     A      - ARRAY OF PRE-EXPONENTIAL (OR PRE-POWER) FACTORS
C              FIRST NTERM(1) ELEMENTS REFER TO P(1),
C              NEXT  NTERM(2) ELEMENTS REFER TO P(2) ETC.
C     NPOWER - ARRAY OF POWERS FOR POTENTIAL TERMS
C              NPOWER HAS SAME ORDERING AS A
C              NPOWER(J) .EQ. 0 INDICATES EXPONENTIAL
C     E      - ARRAY OF EXPONENTS: EACH ELEMENT OF THIS ARRAY
C              CORRESPONDS TO A ZERO IN THE NPOWER ARRAY,
C              IE E(1) CORRESPONDS TO FIRST ZERO, E(2) TO SECOND ETC.
C     CFLAG  - FLAG FOR SCALING POTENTIAL FOR ITYPE = 5 OR 6:
C              SET CFLAG=1 IF INPUT A COEFFICIENTS ARE FOR AN
C              EXPANSION IN C_LM INSTEAD OF Y_LM
C     -------- BELOW ARE FOR POTENTIALS PROJECTION VIA VRTP MECHANISM
C     LVRTP  - LOGICAL FLAG FOR NON-EXPANDED POTENTIAL:
C              MXLAM.LE.0 (DEFAULT) FORCES LVRTP=.TRUE.
C     NPTS   - NUMBERS OF GAUSS POINTS FOR PROJECTING POTENTIAL
C     NPT    - EQUIVALENT TO NPTS(1)
C     NPS    - EQUIVALENT TO NPTS(2)
C     IHOMO  - 2 IF POTENTIAL IS SYMMETRIC ABOUT THETA=90, 1 OTHERWISE
C     ICNSYM - ORDER OF ROTATIONAL SYMMETRY ABOUT PRINCIPAL AXIS
C              ALSO USED FOR 2ND MOLECULE (I.E., IHOMO2) IN ITYPE=3
C              (NOTE: IHOMO & ICNSYM ARE NORMALLY COMPUTED
C               AUTOMATICALLY OR SET BY THE SUPPLIED VRTP ROUTINE)
C     -------- BELOW ARE FOR AUTOMATIC GENERATION OF LAMBDA ARRAY;
C              ONLY FOR PROJECTED  POT'LS (LVRTP = TRUE) IF LMAX.GE.0
C     LMAX   - INCLUDE ALL TERMS FROM 0 TO LMAX IN STEPS OF IHOMO
C     L1MAX  - MAX L1 VALUE FOR MOLECULE-1 (ITYPE=3)
C     L2MAX  - MAX L2 VALUE FOR MOLECULE-2 (ITYPE=3)
C     MMAX   - FOR ITYPE = 5 OR 6, EXCLUDE TERMS WITH M.GT.MMAX
C     IVMIN, IVMAX - FOR ITYPE = 2, V LOOPS FROM IVMIN TO IVMAX
C
      DATA QTYPE/'LAMBDA =','ABS(MU)=','   MU = ','   L1 = ',
     1           '   L2 = ','    L = ','    V = ','V-PRIME=',
     2           '   J =  ','J-PRIME='/
C
C     STATEMENT FUNCTION ...
      F(I)=DBLE(I+I+1)
C
      IF (ICNTRL.GE.0) GOTO 1000
      IF (ICNTRL.EQ.-1) GOTO 2000
      WRITE(6,633) ICNTRL,R
  633 FORMAT(/'  *** ERROR IN POTENL, ICNTRL =',I6,'  R =',E16.8)
      STOP
C
C     ******************************************************************
C     **                                                              **
C     **    CODE BELOW IS FOR AN EVALUATION CALL - CALCULATES P()     **
C     **                                                              **
C     ******************************************************************
 1000 IF (LVRTP) GO TO 1500
C
C     ----- CASE 1 -----
C     EVALUATE RADIAL COEFFICIENTS AS POWERS, EXPONENTIALS OR VSTAR
      IX=0
      IEX=0
      DO 1300 I=1,MXLMB
      SUM=0.D0
      NT=NTERM(I)
      IF (NT.EQ.0) GOTO 1300
      IF (NT.LT.0) GOTO 1250
      DO 1200 IT=1,NT
      IX=IX+1
      NP=NPOWER(IX)
      IF(NP.EQ.0) GOTO 1100
      TERM=R**NP
      IF(ICNTRL.EQ.0) GOTO 1200
      IF(ICNTRL.EQ.1) TERM=DBLE(NP)*TERM/R
      IF(ICNTRL.EQ.2) TERM=DBLE(NP*(NP-1))*TERM/(R*R)
      GOTO 1200
C
 1100 IEX=IEX+1
      TERM=EXP(E(IEX)*R)
      IF(ICNTRL.GT.0) TERM=TERM*E(IEX)**ICNTRL
 1200 SUM=SUM+A(IX)*TERM
      GOTO 1300
CKSz  Pass lambda to potential routine to check data consistency
C1250 IF(ICNTRL.EQ.0) CALL VSTAR (I,R,SUM)
 1250 IF(ICNTRL.EQ.0) CALL VSTAR (mxlmb,lambda,I,R,SUM)
! MLD
!      IF(ICNTRL.EQ.1) CALL VSTAR1(I,R,SUM)
!      IF(ICNTRL.EQ.2) CALL VSTAR2(I,R,SUM)
 1300 P(I)=SUM
      RETURN
C
 1500 IF(ITSAVE.GE.100) GOTO 1900
C
C     ----- CASE 2 -----
C     EXPLICIT PROJECTION OF LEGENDRE COMPONENTS VIA VRTP
      DO 1700 I=1,MXLMB
 1700 P(I)=0.D0
      NTOT=1
      DO 1710 ID=1,NDIM
      INX(ID)=1
C     BELOW COULD BE ELIMINATED BY 'SAVE NTOT'
 1710 NTOT=NTOT*NPTS(ID)
C     START YPT() INDEX = IX;
C       IX COUNTS DOWN LAMBDA THEN 1ST DIMENSION, 2ND DIMENSION, ...
      IX=IXFAC
      DO 1800 I=1,NTOT
      WEIGHT=1.D0
      DO 1810 ID=1,NDIM
      COSANG(ID)=XPT(INX(ID),ID)
 1810 WEIGHT=WEIGHT*XWT(INX(ID),ID)
      CALL VRTP(ICNTRL,R,SUM)
      SUM=SUM*WEIGHT
C     ACCUMULATE CONTRIBUTIONS TO EACH P()
      DO 1820 IL=1,MXLMB
      IX=IX+1
 1820 P(IL)=P(IL)+SUM*X(IX)
C     INCREMENT THE INDICES FOR EACH DIMENSION, INX(ID), STARTING W/ 1ST
      ID=1
 1830 INX(ID)=INX(ID)+1
      IF (INX(ID).LE.NPTS(ID)) GO TO 1800
C     WE REACH HERE IF WE'VE HIT MAX FOR THIS DIMENSION; START NEXT,
      INX(ID)=1
      ID=ID+1
      IF (ID.LE.NDIM) GO TO 1830
C     IF WE REACH HERE WE SHOULD HAVE COUNTED ALL NTOT ELEMENTS
      IF (I.EQ.NTOT) GO TO 1800
!      WRITE(6,*) ' POTENL. ERROR IN PROJECTION.  NO. TERMS',I
      STOP
 1800 CONTINUE
      RETURN
C
C     ----- CASE 3 -----
C     UNEXPANDED POT'L AS FUNCTION OF ANGLES, FROM VRTP
 1900 CALL VRTP(ICNTRL,R,P)
      RETURN
C
C     ******************************************************************
C     **                                                              **
C     **    CODE BELOW IS FOR AN INITIALIZATION CALL                  **
C     **                                                              **
C     ******************************************************************
C
 2000 PI=ACOS(-1.D0)
C
C     ------ NEXT TWO STATEMENTS ARE NEEDED IF USING AN INTERNAL   -----
C     ------ X() ARRAY; I.E. NOT USING MOLSCAT /MEMORY/ MECHANISM
C     MX=MXX
C     IXNEXT=1
C     ------------------------------------------------------------------
C
!      WRITE(6,634)
  634 FORMAT(/'  STANDARD MOLSCAT POTENL ROUTINE (AUG 94) ',
     1  'CALLED FOR POTENTIAL.'//
     2  '  /POTL/  DATA ARE --')
C     INITIALIZE NAMELIST VARIABLES BEFORE READ
      RM=1.D0
      EPSIL=1.D0
      MXLAM=0
      LMAX=-1
      L2MAX=-1
      MMAX=-1
      IVMIN=-1
      IVMAX=-1
      IHOMO=1
      ICNSYM=1
      IHOMO2=1
      ICNSY2=1
      CFLAG=0
      DO 2999 ID=1,MXDIM
 2999 NPTS(ID)=0
      LVRTP=.FALSE.
      NPOTL=-1
C
C     NAMELIST/POTL/ RM,EPSIL,MXLAM,MXSYM,LAMBDA,NPOTL,NTERM,
C    1   A,NPOWER,E,CFLAG,LVRTP,NPT,NPS,
C    2   IHOMO,ICNSYM,LMAX,L1MAX,L2MAX,MMAX,IVMIN,IVMAX,
C    3   NPTS,IHOMO2,ICNSY2
C-------------------------------------------------------------------
C     ARRAYS FOR NAMELIST SIMULATOR
C     LOCN(1)=LOC(RM)
C     LOCN(2)=LOC(EPSIL)
C     LOCN(3)=LOC(MXLAM)
C     LOCN(4)=LOC(MXSYM)
C     LOCN(5)=LOC(LAMBDA)
C     LOCN(6)=LOC(NPOTL)
C     LOCN(7)=LOC(NTERM)
C     LOCN(8)=LOC(A)
C     LOCN(9)=LOC(NPOWER)
C     LOCN(10)=LOC(E)
C     LOCN(11)=LOC(CFLAG)
C     INDX(11)=4
C     LOCN(12)=LOC(LVRTP)
C     INDX(12)=3
C     LOCN(13)=LOC(NPT)
C     LOCN(14)=LOC(NPS)
C     LOCN(15)=LOC(IHOMO)
C     LOCN(16)=LOC(ICNSYM)
C     LOCN(17)=LOC(LMAX)
C     LOCN(18)=LOC(L1MAX)
C     LOCN(19)=LOC(L2MAX)
C     LOCN(20)=LOC(MMAX)
C     LOCN(21)=LOC(IVMIN)
C     LOCN(22)=LOC(IVMAX)
C     LOCN(23)=LOC(NPTS)
C     LOCN(24)=LOC(IHOMO2)
C     LOCN(25)=LOC(ICNSY2)
C     CALL NAMLIS('&POTL ',PNAMES,LOCN,INDX,25,IEOF)
C-------------------------------------------------------------------
!      write(*,*) NPOTL
	  open(5,file = './PES_H2OHe/pes.dat',status = 'old')
	  READ(5,POTL)
C
!      write(*,*) NPOTL
!      IF (NPOTL.NE.-1) WRITE(6,602) NPOTL
  602 FORMAT(/' *** POTENL.  CURRENT CODE IGNORES INPUT &POTL NPOTL =',
     1        I6)
      ITYPE=ITYP-10*(ITYP/10)
! MLD
!      write(*,*)'potenl itype,mxsym',itype,mxsym

      LCALC=.FALSE.



C
C     FOR ITYPE=9, POTIN9 MUST EITHER RESET ITYPE TO ONE OF THE
C     RECOGNISED VALUES OR MUST DO ALL THE REST OF THE SETUP WORK
C
! MLD
!      IF(ITYPE.EQ.9) 
!     1  CALL POTIN9(ITYPE,LAM,MXLAM,NPTS,NDIM,XPT,XWT,MXPT,
!     2  X,MX,IXFAC)
C     NOTE THAT EVEN IF POTIN9 WAS CALLED, ITYPE MAY NOT BE 9 NOW
      IF(ITYPE.EQ.9) RETURN
C
      IF (CFLAG.EQ.1 .AND. .NOT.(ITYPE.EQ.5.OR.ITYPE.EQ.6)) 
     1  WRITE(6,604) CFLAG,ITYPE
  604 FORMAT(/' *** '/
     2  ' *** POTENL. INPUT &POTL CFLAG =',I2,' NOT CONSISTENT WITH ',
     3  'ITYPE =',I4/' ***',9X,'DO YOU REALLY WANT THIS?'/' ***')
C
      XLAM=.FALSE.
C
C     CHECK FOR LVRTP OR MXLAM.LE.0, ("UNEXPANDED" POTENTIAL CASE).
C
      IF(MXLAM.LE.0) LVRTP=.TRUE.
      IF (.NOT.LVRTP) GO TO 3998
C
!      WRITE(6,636)
  636 FORMAT(/'  POTENTIAL IS **NOT** EXPANDED IN ANGULAR FUNCTIONS.'//
     1  '  A SUITABLE VRTP ROUTINE MUST BE SUPPLIED.')
      IF (ITYP.GT.100 .OR.
     1    ITYPE.EQ.1 .OR. ITYPE.EQ.2 .OR. ITYPE.EQ.3. OR.
     2    ITYPE.EQ.5 .OR. ITYPE.EQ.6)
     2    GO TO 3010
      WRITE(6,637)  ITYP
  637 FORMAT('  *** POTENL.  ERROR VRTP NOT SUPPORTED FOR ITYPE =',I6)
      STOP
C
 3010 FACTOR=1.D0
      ITSAVE=ITYP
C     CHECK/PROCESS IHOMO/ICNSYM INPUT
      IF (IHOMO.NE.1.OR.ICNSYM.NE.1.OR.IHOMO2.NE.1.OR.ICNSY2.NE.1) THEN
        WRITE(6,681) IHOMO,ICNSYM,IHOMO2,ICNSY2
  681   FORMAT('  INPUT VALUES ARE IHOMO =',I2,', ICNSYM =',I2,
     1    ', IHOMO2 =',I2,', ICNSY2 =',I2/
     2    '  THESE MAY BE OVERRIDDEN BY VRTP')
C       FOR COMPATIBILITY WITH OLD CODE WHICH USES ICNSYM FOR IHOMO2 ...
        IF (ITYPE.EQ.3.AND.IHOMO2.NE.1.AND.ICNSYM.EQ.1) ICNSYM=IHOMO2
      ENDIF
C     INITIALIZATION CALL TO VRTP.
C     IT MAY USE OR SET RM, EPSIL, IHOMO, ICNSYM
      CALL VRTP(ICNTRL,RM,EPSIL)
C
C     CHECK FOR VALID IHOMO, ICNSYM AFTER CALL TO VRTP
      IF (IHOMO.NE.1) THEN
        IF (IHOMO.NE.2) THEN
          WRITE(6,606) IHOMO
  606     FORMAT(/' *** POTENL. ILLEGAL IHOMO =',I6,' FROM &POTL INPUT'
     1       ,' OR VRTP')
          STOP
        ELSE
          WRITE(6,*) ' &POTL INPUT OR VRTP SPECIFIES',
     1               ' HOMONUCLEAR SYMMETRY.'
        ENDIF
      ENDIF
      IF (ICNSYM.LE.0) THEN
        WRITE(6,*) ' *** POTENL. ILLEGAL &POTL ICNSYM =',ICNSYM
        STOP
      ELSEIF (ICNSYM.GT.1) THEN
!        WRITE(6,*) ' ICNSYM INPUT OR FROM VRTP SPECIFIES',
!     1             ' AXIAL SYMMETRY, ICNSYM =',ICNSYM
      ENDIF
C *** CHECK IHOMO2, ICNSY2 ???
C
      IF(ITYP.GT.100.AND.MXLAM.LE.0) GOTO 3100
C
C     ******************************************************************
C     CODE BELOW IS CASE 2 -- PROJECTED EXPANSION USING VRTP
C       SYMMETRIES INPUT VIA *EITHER* LMAX *OR* MXLAM,LAMBDA
C       LATTER TAKES PRECEDENCE IF BOTH ARE SPECIFIED.
C     ******************************************************************
C     NPOTL FOR THIS CASE CALCULATED IN CODE BEGINNING AT 3999
C
      IF (LMAX.LT.0.AND.MXLAM.LE.0) THEN
        WRITE(6,*) ' *** POTENL. LMAX.LT.0.AND.MXLAM.LE.0'
        WRITE(6,*) '             YOU MUST SPECIFY SYMMETRIES VIA ONE',
     1             ' OR THE OTHER IN &POTL'
        STOP
      ELSEIF (LMAX.GE.0.AND.MXLAM.GT.0) THEN
        WRITE(6,607) LMAX
  607   FORMAT('  *** POTENL. IGNORING INPUT &POTL LMAX =',I4,
     1         ' IN FAVOR OF MXLAM, LAMBDA() VALUES')
        LMAX=-1
      ENDIF
C
      IF (ITYP.GT.100) THEN
        WRITE(6,699)
  699   FORMAT(/' *** NOTE *** REQUESTED PROJECTED EXPANSION IS '
     1         ,'GENERALLY NOT DESIRABLE FOR IOS CALCULATIONS.'/
     2          '              STANDARD IOS/VRTP PROCESSING CAN BE'
     3         ,' OBTAINED BY SETTING MXLAM=0 IN &POTL'/)
C       IN EVALUATION CALL, FLAG TO PROJECT IS ITSAVE.LT.100
        ITSAVE=ITSAVE-10*(ITSAVE/10)
      ENDIF
C
C     FOR THE COUPLING CASES ALLOWED HERE (1,2,3,5,6) PROJECTING OUT
C     THE POTENTIAL  COEFFICIENTS INVOLVES A QUADRATURE OVER THETA.
C     GET GAUSS-LEGENDRE QUADRATURE POINTS AND WEIGHTS,
C     AND CHECK THAT NUMBER OF POINTS IS SENSIBLE.
C
!      WRITE(6,635) NPT
  635 FORMAT(I4,'-POINT GAUSSIAN QUADRATURE REQUESTED TO PROJECT',
     1   ' COMMON THETA-1 COMPONENT')
      IF(LMAX.GE.0) THEN
        MXLM=LMAX+1
      ELSE
        IF(ITYPE.EQ.1) THEN
          IADD=1
        ELSEIF(ITYPE.EQ.2) THEN
          IADD=3
        ELSEIF(ITYPE.EQ.3) THEN
          IADD=3
        ELSEIF(ITYPE.EQ.5 .OR. ITYPE.EQ.6) THEN
          IADD=2
        ELSE
          WRITE(6,638) ITYPE
  638     FORMAT(/' *** POTENL. ILLEGAL LOGICAL PATH.  ITYPE =',I6)
          STOP
        ENDIF
        MXLM=0
        IND=1
        DO 3011 I=1,MXLAM
        MXLM=MAX(MXLM,LAMBDA(IND))
 3011   IND=IND+IADD
        MXLM=MXLM+1
      ENDIF
C
      IF(MXLM.GT.NPT) WRITE(6,648) NPT,MXLM
  648 FORMAT(I4,'-POINT QUADRATURE IS INSUFFICIENT TO PROJECT OUT',
     1   ' LEGENDRE COMPONENTS REQUESTED'/'     INCREASED TO ',I3,
     2   ' ACCORDINGLY')
      NPT=MAX(NPT,MXLM)
C     NB ABOVE CODE GUARANTEES THAT NPT.GE.1
      IF(NPT.GT.MXPT) GO TO 9400
C
      NEXP=NPT
      CALL GAUSSP(-1.D0,1.D0,NPT,XPT(1,1),XWT(1,1))
      IF(NPT.NE.NEXP) THEN
C       NB THIS BRANCH SHOULD NOT OCCUR WITH CURRENT GAUSSP
        WRITE(6,653) NEXP
  653   FORMAT(I4,'-POINT GAUSS-LEGENDRE QUADRATURE IS NOT AVAILABLE')
        STOP
      ENDIF
C
      IF(IHOMO.EQ.2) THEN
        DO 3014 IPT=1,NPT/2
 3014   XWT(IPT,1)=2.D0*XWT(IPT,1)
        NPT=(NPT+1)/2
        WRITE(6,*) ' HOMONUCLEAR SYMMETRY: ONLY HALF OF',
     1             ' THE THETA-1 POINTS WILL BE USED'
      ENDIF
C
C     SET UP OTHER QUADRATURE POINTS AND WEIGHTS FOR PROJECTING
C     POTENTIAL COMPONENTS FOR ITYPE=1,2,3,5,6
C
      IF (ITYPE.EQ.1)  GO TO 3001
      IF (ITYPE.EQ.2)  GO TO 3002
      IF (ITYPE.EQ.3)  GO TO 3003
      IF (ITYPE.EQ.5)  GO TO 3005
      IF (ITYPE.EQ.6)  GO TO 3005
      WRITE(6,638) ITYPE
      STOP
C
C     ITYPE = 1: ATOM + LINEAR RIGID ROTOR
C
 3001 IF(LMAX.GE.0) THEN
        LCALC=.TRUE.
        MXLAM=0
        DO 3012 L=0,LMAX,IHOMO
        MXLAM=MXLAM+1
        IF (MXLAM.GT.MXLMB) GO TO 9500
 3012   LAM(MXLAM)=L
      ELSE
        DO 3112 I=1,MXLAM
 3112   LAM(I)=LAMBDA(I)
      ENDIF
      XLAM=.TRUE.
C
      NDIM=1
      IF (NDIM.GT.MXDIM) GO TO 9300
      NTOT=NPT
      IXFAC=MX-MXLAM*NTOT
      MX=IXFAC
      IF (MX+1.LT.IXNEXT) GO TO 9600
      IX=IXFAC
      DO 3016 IP=1,NPT
      DO 3016 IL=1,MXLAM
      L=LAM(IL)
      IF(MOD(L,IHOMO).NE.0) THEN
        WRITE(6,668) IL,IHOMO,ICNSYM,L
  668   FORMAT(/' *** POTENL.  SYMMETRY',I4,' IS INCONSISTENT ',
     1          'WITH IHOMO =',I2,' OR ICNSYM =',I2,'  INDICES:',5I4)
        STOP
      ENDIF
      IX=IX+1
 3016 X(IX)=SQRT(DBLE(L)+0.5D0)*PLM(L,0,XPT(IP,1))
      GOTO 3999
C
C     ITYPE = 2: ATOM + VIBRATING DIATOM
C
 3002 IF(LMAX.GE.0) THEN
        LCALC=.TRUE.
        IF (IVMIN.LT.0) THEN
          WRITE(6,*) ' *** POTENL. IVMIN MUST BE SPECIFIED IN &POTL'
          WRITE(6,*) '             TO GENERATE SYMMETRIES AS REQUESTED'
     1               ,' BY &POTL LMAX',LMAX
          STOP
        ENDIF
        IF (IVMAX.LT.IVMIN) THEN
          WRITE(6,*) ' *** POTENL. IVMAX.LT.IVMIN INCREASED TO IVMIN'
          IVMAX=IVMIN
        ENDIF
C       NB GIVEN /CMBASE/ WE COULD GET IVMIN,IVMAX FROM JLEVEL
        MXLAM=0
        DO 3018 L=0,LMAX,IHOMO
        DO 3018 IV=IVMIN,IVMAX
        DO 3018 JV=IVMIN,IV
        MXLAM=MXLAM+1
        IF (3*MXLAM.GT.MXLMB) GO TO 9500
        LAM(3*MXLAM-2)=L
        LAM(3*MXLAM-1)=IV
 3018   LAM(3*MXLAM  )=JV
      ELSE
        IF (3*MXLAM.GT.MXLMB) GO TO 9500
        DO 3118 I=1,3*MXLAM
 3118   LAM(I)=LAMBDA(I)
      ENDIF
      XLAM=.TRUE.
C
!      WRITE(6,672) NPS
  672 FORMAT(I4,'-POINT GAUSSIAN QUADRATURE REQUESTED TO INTEGRATE ',
     1   ' OVER HARMONIC OSCILLATOR FUNCTIONS')
      MAXV=0
      DO 3021 I=1,MXLAM
      MAXV=MAX(MAXV,LAM   (3*I))
 3021 MAXV=MAX(MAXV,LAM   (3*I-1))
      IF(2*MAXV-1.GT.NPS) THEN
        NPSOLD=NPS
        NPS=2*MAXV-1
        WRITE(6,670) NPSOLD,MAXV,NPS
  670   FORMAT(/'  *** WARNING IN POTENL - ',I2,'-POINT QUADRATURE ',
     1    'NOT ENOUGH FOR MATRIX ELEMENTS UP TO V OR K =',I3/
     2    6X,'NPS INCREASED TO',I3)
      ENDIF
      IF (NPS.GT.MXPT) GO TO 9400
      NPSOLD=NPS
      CALL GAUSHP(NPS,XPT(1,2),XWT(1,2))
      IF (NPS.NE.NPSOLD) THEN
        WRITE(6,*) ' *** POTENL. GAUSHP CANNOT SUPPLY REQUESTED NPS',NPS
        STOP
      ENDIF
      IF (MAXV+1.GT.MXHERM) THEN
        WRITE(6,*) ' *** POTENL. DIMENSION OF H INSUFFICIENT FOR',
     1             'REQUIRED HERMITE POLYNOMIALS'
        WRITE(6,*) ' ***         SUPPPLIED, REQUIRED',MXHERM,MAXV+1
        STOP
      ENDIF
C
      NDIM=2
      IF (NDIM.GT.MXDIM) GO TO 9300
      NTOT=NPT*NPS
      IXFAC=MX-MXLAM*NTOT
      MX=IXFAC
      IF (MX+1.LT.IXNEXT) GO TO 9600
      IX=IXFAC
      DO 3020 IPX=1,NPS
C     GET HERMITE POLYNOMIALS AND NORMALISE THEM
      CALL HERM(H,MAXV+1,XPT(IPX,2))
      SUM=SQRT(PI)
      DO 3022 NV=1,MAXV+1
      H(NV)=H(NV)/SQRT(SUM)
 3022 SUM=SUM*DBLE(2*NV)
      DO 3020 IPT=1,NPT
      DO 3020 IL=1,MXLAM
      L=LAM(3*IL-2)
      IX=IX+1
 3020 X(IX)=SQRT(DBLE(L)+0.5D0)*PLM(L,0,XPT(IPT,1))*
     1           H(1+LAM(3*IL-1))*H(1+LAM(3*IL))
      GOTO 3999
C
C     ITYPE = 3 LINEAR ROTOR - LINEAR ROTOR
C
 3003 IF (L1MAX.GE.0) THEN
        LCALC=.TRUE.
        IF (L2MAX.LT.0) L2MAX=L1MAX
        MXLAM=0
        DO 3034 L1=0,L1MAX,IHOMO
        DO 3034 L2=0,L2MAX,ICNSYM
        LMIN=ABS(L1-L2)
C       19 OCT 95: LMAX->LTOP BELOW
        LTOP=L1+L2
        DO 3034 LL=LMIN,LTOP,2
        MXLAM=MXLAM+1
        IF (3*MXLAM.GT.MXLMB) GO TO 9500
        LAM(3*MXLAM-2)=L1
        LAM(3*MXLAM-1)=L2
 3034   LAM(3*MXLAM)=LL
      ELSE
        IF (3*MXLAM.GT.MXLMB) GO TO 9500
        L1MAX=0
        L2MAX=0
        DO 3134 I=1,MXLAM
        LAM(3*I-2)=LAMBDA(3*I-2)
        L1MAX=MAX(L1MAX,LAMBDA(3*I-2))
        LAM(3*I-1)=LAMBDA(3*I-1)
        L2MAX=MAX(L2MAX,LAMBDA(3*I-1))
 3134   LAM(3*I)=LAMBDA(3*I)
      ENDIF
      XLAM=.TRUE.
      MAXV=MIN(L1MAX,L2MAX)
      IF (NPS.LE.L2MAX) WRITE(6,648) NPS,L2MAX
      NPS=MAX(NPS,L2MAX)
      NEXP=NPS
!      WRITE(6,685) NPS
  685 FORMAT(I4,'-POINT GAUSSIAN QUADRATURE REQUESTED TO PROJECT',
     1   ' LEGENDRE COMPONENTS - MOLECULE 2')
      CALL GAUSSP(-1.D0,1.D0,NPS,XPT(1,2),XWT(1,2))
      IF(NPS.NE.NEXP) THEN
C       NB THIS BRANCH SHOULD NOT OCCUR WITH CURRENT GAUSSP
        WRITE(6,653) NEXP
        STOP
      ENDIF
C     IF SYMMETRIC 2ND MOLECULE, REDUCE POINTS/INCREASE WEIGHTS
      IF(ICNSYM.EQ.2) THEN
        DO 3314 IPT=1,NPS/2
 3314   XWT(IPT,2)=2.D0*XWT(IPT,2)
        NPS=(NPS+1)/2
        WRITE(6,*) ' HOMONUCLEAR MOLECULE 2:',
     1             ' ONLY HALF THE POINTS WILL BE USED'
      ENDIF
C     SET UP GAUSS-MEHLER INTEGRATION FOR PHI ON (0,PI)
      WRITE(6,675) NPTS(3)
      IF (NPTS(3).LT.MAXV) THEN
        WRITE(6,*) ' *** POTENL. INSUFFICIENT NUMBER OF POINTS',
     1             ' REQUESTED FOR PHI',NPTS(3)
        WRITE(6,*) '             INCREASED TO',MAXV
        NPTS(3)=MAXV
      ENDIF
      IF (NPTS(3).GT.MXPT) GO TO 9400
      FACTL=PI/DBLE(NPTS(3))
      TH=-FACTL/2.D0
      DO 3342 IX=1,NPTS(3)
      TH=TH+FACTL
      XWT(IX,3)=(2.D0*FACTL)
 3342 XPT(IX,3)=TH
      NDIM=3
      IF (NDIM.GT.MXDIM) GO TO 9300
      NTOT=NPTS(1)*NPTS(2)*NPTS(3)
      IXFAC=MX-MXLAM*NTOT
      MX=IXFAC
      IF (MX+1.LT.IXNEXT) GO TO 9600
C
      IX=IXFAC
C     N.B. USE OF YRR MIGHT BE EXPENSIVE; CODE COULD BE MODIFIED
C       SIMILARLY TO THAT IN IOSB1
      PI8=8.D0*PI*PI
      DO 3329 IP3=1,NPTS(3)
      DO 3329 IPX=1,NPTS(2)
      DO 3329 IPT=1,NPTS(1)
      DO 3329 IL=1,MXLAM
      L1=LAM(3*IL-2)
      L2=LAM(3*IL-1)
      LL=LAM(3*IL)
      IX=IX+1
 3329 X(IX)=YRR(L1,L2,LL,XPT(IPT,1),XPT(IPX,2),XPT(IP3,3))*PI8/F(LL)
      GOTO 3999
C
C     ITYPE = 5 OR 6: ATOM + NON-LINEAR RIGID ROTOR
C
 3005 IF(LMAX.GE.0) THEN
        LCALC=.TRUE.
        IF(MMAX.LT.0) MMAX=LMAX
        MXLAM=0
        DO 3024 L=0,LMAX
        DO 3024 M=0,MIN(L,MMAX),ICNSYM
C       ONLY INCLUDE SYMMETRIES CONSISTENT W/ IHOMO, ICNSYM
        IF(MOD(L+M,IHOMO).NE.0) GOTO 3024
        MXLAM=MXLAM+1
        IF (2*MXLAM.GT.MXLMB) GO TO 9500
        LAM(2*MXLAM-1)=L
        LAM(2*MXLAM  )=M
 3024   CONTINUE
      ELSE
        IF (2*MXLAM.GT.MXLMB) GO TO 9500
        DO 3124 I=1,2*MXLAM
 3124   LAM(I)=LAMBDA(I)
      ENDIF
      XLAM=.TRUE.
C
!      WRITE(6,675) NPS
  675 FORMAT(I4,'-POINT QUADRATURE REQUESTED TO PROJECT OUT',
     1   ' PHI COMPONENTS')
      MAXV=0
      DO 3025 I=1,MXLAM
 3025 MAXV=MAX(MAXV,LAM   (2*I))
      IF(MAXV.GT.(NPS-1)*ICNSYM) THEN
        NPSOLD=NPS
        NPS=1+(MAXV+ICNSYM-1)/ICNSYM
        WRITE(6,670) NPSOLD,MAXV,NPS
      ENDIF
      IF (NPS.GT.MXPT) GO TO 9400
C
      NDIM=2
      IF (NDIM.GT.MXDIM) GO TO 9300
      NTOT=NPT*NPS
      DO 3026 IPX=1,NPS
      XPT(IPX,2)=PI*DBLE(2*IPX-1)/DBLE(2*ICNSYM*NPS)
 3026 XWT(IPX,2)=SQRT(PI+PI)/DBLE(NPS)
      IXFAC=MX-MXLAM*NTOT
      MX=IXFAC
      IF (MX+1.LT.IXNEXT) GO TO 9600
C
      IX=IXFAC
      DO 3029 IPX=1,NPS
      DO 3029 IPT=1,NPT
      DO 3029 IL=1,MXLAM
      L=LAM(2*IL-1)
      M=LAM(2*IL)
      IF(MOD(L+M,IHOMO).NE.0 .OR. MOD(M,ICNSYM).NE.0) THEN
        WRITE(6,668) I,IHOMO,ICNSYM,L,M
        STOP
      ENDIF
      IX=IX+1
 3029 X(IX)=PLM(L,M,XPT(IPT,1))*COS(DBLE(M)*XPT(IPX,2))
      GOTO 3999
C
C    *******************************************************************
C       CODE BELOW IS CASE 3 - NON-EXPANDED POTENTIAL, IOS ONLY
C    *******************************************************************
C     MXLAM,NPOTL SET HERE
C
 3100 IF(ITYP.EQ.102) GO TO 3192
C     BELOW IS UNIFIED CODE FOR ITYPE=101,103,105,106 (& 102 W/MXLAM=0)
      NQPL=1
      IF(ITYP.EQ.103) NQPL=3
      IF(ITYP.EQ.105 .OR. ITYP.EQ.106) NQPL=2
 3190 DO 3101 I=1,NQPL
 3101 LAM(I)=0
      XLAM=.TRUE.
      NPOTL=1
      MXLAM=1
      GOTO 9050
C
C     CODE FOR ATOM-VIBRATING DIATOM IOS, IE., CLARY'S VCC-IOS
C       WHERE THE ANGLE DEPENDENCE OF POTENTIAL IS NOT EXPANDED.
C>>   IT WOULD MAKE GOOD SENSE TO USE IVMIN,IVMAX TO GENERATE HERE.
C
 3192 NQPL=3
C     IF MXLAM=0, ASSUME V=V'=0; PROCESS SAME AS OTHER ITYPES
      IF(MXLAM.EQ.0) GOTO 3190
      MXLAM=ABS(MXLAM)
      WRITE(6,621) MXLAM
  621 FORMAT(/'  POTENL, ITYPE=102.  NEGATIVE MXLAM REQUESTS',I3,
     1       ' SYMMETRIES'//'  SYMMETRY    LAMBDA     VIB1      VIB2')
      DO 3104 I=1,MXLAM
      IF (LAMBDA(3*I-2).EQ.0) GO TO 3102
      WRITE(6,622)
  622 FORMAT('  *** WARNING.  INPUT LEGENDRE SYMMETRY .GT. ZERO BELOW',
     1       ' WILL BE IGNORED AND SET TO ZERO.')
 3102 LAM(3*I-2)=0
      LAM(3*I-1)=LAMBDA(3*I-1)
      LAM(3*I  )=LAMBDA(3*I  )
 3104 WRITE(6,623) I,LAMBDA(3*I-2),LAMBDA(3*I-1),LAMBDA(3*I)
  623 FORMAT(1X,I8,I9,2I10)
      XLAM=.TRUE.
      NPOTL=1
      GOTO 9050
C
C     STATEMENT BELOW BEGINS PROCESSING FOR LVRTP=.FALSE.
 3998 IF (LMAX.GE.0) THEN
        WRITE(6,*) ' *** POTENL. &POTL REQUESTS MXLAM.GT.0 AND ',
     1             'LVRTP=.FALSE.'
        WRITE(6,*) '             &POTL LMAX.GT.0 IS IGNORED;',
     1             ' AND MXLAM, LAMBDA INPUT USED INSTEAD'
        LMAX=-1
      ENDIF
C
C     ATTEMPT TO PROCESS ITYPE AND POTENTIAL DESCRIPTION NUMBERS
 3999 QOUT=.TRUE.
      NPOTL=MXLAM
      NQPL=1
!      WRITE(6,639)
  639 FORMAT(/'  ANGULAR DEPENDENCE OF POTENTIAL EXPANDED IN TERMS OF')
      ITYPE=ITYP-10*(ITYP/10)
      IF(ITYPE.EQ.1) GOTO 2001
      IF(ITYPE.EQ.2) GOTO 2002
      IF(ITYPE.EQ.3) GOTO 2003
      IF(ITYPE.EQ.4) GOTO 2004
      IF(ITYPE.EQ.5) GOTO 2005
      IF(ITYPE.EQ.6) GOTO 2005
      IF(ITYPE.EQ.7) GOTO 2002
      IF(ITYPE.EQ.8) GOTO 2008
C
      WRITE(6,640) ITYPE
  640 FORMAT(/' *** POTENL. ITYPE =',I4,' CANNOT BE PROCESSED TO',
     1   ' DETERMINE THE POTENTIAL SYMMETRY LABLES')
      QOUT=.FALSE.
      GOTO 2100
C
 2001 NQPL=1
      QNAME(1)=QTYPE(1)
      WRITE(6,641)
  641 FORMAT('  LEGENDRE POLYNOMIALS, P(LAMBDA).')
      IF(LCALC) WRITE(6,615) LMAX,IHOMO
  615 FORMAT('  POTENTIAL SYMMETRIES GENERATED FROM LMAX =',I3,
     1   ' AND IHOMO =',I2)
      GOTO 2100
C
 2002 NQPL=3
      QNAME(1)=QTYPE(1)
      QNAME(2)=QTYPE(7)
      QNAME(3)=QTYPE(8)
      WRITE(6,641)
      WRITE(6,642)
  642 FORMAT('  INTEGRATED OVER DIATOM VIBRATIONAL FUNCTIONS')
      IF(ITYPE.EQ.2) THEN
        IF(LCALC) WRITE(6,616) LMAX,IHOMO,IVMIN,IVMAX
  616   FORMAT('  POTENTIAL SYMMETRIES GENERATED FROM LMAX =',I3,
     1   ' AND IHOMO =',I2/'  WITH V FROM',I2,' TO',I2)
      ELSEIF (ITYPE.EQ.7) THEN
        WRITE(6,643)
  643   FORMAT('  FOR EACH PAIR OF V,J LEVELS')
        NQPL=5
        QNAME(3)=QTYPE(9)
        QNAME(4)=QTYPE(8)
        QNAME(5)=QTYPE(10)
      ENDIF
C     DETERMINE NPOTL FOR USE OF IV(); ITYPE=2 AND 7 IN THIS VERSION
      NPOTL=0
      IF (XLAM) THEN
        DO 2010 I=1,MXLAM
 2010   NPOTL=MAX0(NPOTL,LAM((I-1)*NQPL+1))
      ELSE
        DO 2110 I=1,MXLAM
 2110   NPOTL=MAX0(NPOTL,LAMBDA((I-1)*NQPL+1))
      ENDIF
      NPOTL=NPOTL+1
      GOTO 2100
C
 2003 NQPL=3
      QNAME(1)=QTYPE(4)
      QNAME(2)=QTYPE(5)
      QNAME(3)=QTYPE(6)
!      WRITE(6,644)
  644 FORMAT('  CONTRACTED NORMALISED SPHERICAL HARMONICS, SUM',
     1   '(M1,M2,M) C(L1,M1,L2,M2,L,M) Y(L1,M1) Y(L2,M2) Y(L,M)'/
     2   '  SEE RABITZ, J. CHEM. PHYS. 57, 1718 (1972)')
      IF(LCALC) THEN
        WRITE(6,*) ' FOR MOLECULE - 1'
        WRITE(6,615) L1MAX,IHOMO
        WRITE(6,*) ' FOR MOLECULE - 2'
        WRITE(6,615) L2MAX,ICNSYM
      ENDIF
      GOTO 2100
C
 2004 NQPL = 4
      QNAME(1) = QTYPE(4)
      QNAME(2) = QTYPE(3)
      QNAME(3) = QTYPE(5)
      QNAME(4) = QTYPE(6)
      WRITE(6,448)
  448 FORMAT(' CONTRACTION OF SPHERICAL HARMONICS AND ROTATION',
     1       'MATRICES'/
     2  '     SEE T.R. PHILLIPS, ET AL. JCP 101, 5824 (1994)')
      GO TO 2100
C
 2005 NQPL=2
      QNAME(1)=QTYPE(1)
      QNAME(2)=QTYPE(2)
!      WRITE(6,645)
  645 FORMAT('  NORMALISED SPHERICAL HARMONICS: (Y(LAM,MU) + ',
     1       '(-)**MU Y(LAM,-MU)) / (1+DELTA(MU,0))')
      IF(LCALC) WRITE(6,617) LMAX,IHOMO,MMAX,ICNSYM
  617 FORMAT('  POTENTIAL SYMMETRIES GENERATED FROM LMAX =',I3,
     1   ', IHOMO =',I2,', MMAX =',I3,' AND ICNSYM =',I2)
      IF(CFLAG.EQ.1) THEN
        IF(LVRTP) THEN
          WRITE(6,662)
        ELSE
          WRITE(6,646)
  646     FORMAT(/' COEFFICIENTS IN POTENTIAL WILL BE MULTIPLIED BY ',
     1    'SQRT(4*PI/(2*LAM+1)) TO BRING POTENTIAL INTO CORRECT FORM')
        ENDIF
      ENDIF
      GOTO 2100
C
C     SEEMS THAT CODE BELOW TREATS NPOTL SAME AS VERSION 9 (SG JAN 94)
 2008 NQPL=2
      QNAME(1)=QTYPE(4)
      QNAME(2)=QTYPE(5)
      NPOTL=NPTL
      WRITE(6,647) NPOTL
  647 FORMAT('  SURFACE FOURIER COMPONENTS'/'  NPOTL =',I2,
     1   ' FROM SURBAS')
      GOTO 2100
C
C    *******************************************************************
C       CODE BELOW IS MAINLY FOR CASE 1 - EXPANDED POTENTIAL
C       USING NTERM,NPOWER,A,E *OR* VSTAR MECHANISM
C    *******************************************************************
C       HOWEVER, CASE 2 - EXPANDED POT'L PROJECTED FROM VRTP
C       ALSO RUNS THROUGH THIS CODE, BUT DOES LITTLE
C    *******************************************************************
C
 2100 IF (.NOT.XLAM.AND.NQPL*MXLAM.GT.MXL) WRITE(6,650) MXLAM,NQPL,MXL
  650 FORMAT(/' *** POTENL. MXLAM =',I4,' AND NQPL =',I2,
     1       '  APPEAR TO EXCEED INTERNAL STORAGE IN LAMBDA(',I5,')'/
     2       '              WILL ATTEMPT TO PROCEED.')
      IX=0
      IEX=0
      IQ=0
      NPX=0
      DO 9000 I=1,MXLAM
C     OUTPUT SYMMETRY DESCRIPTION ONLY IF MXLAM,LAMBDA WERE USED
C       I.E., LCALC=.FALSE.
      IF(.NOT.LCALC) THEN
!        WRITE(6,651) I
  651   FORMAT(/'  INTERACTION POTENTIAL FOR SYMMETRY TYPE NUMBER',I4)
!        IF(QOUT) WRITE(6,652) (QNAME(J),LAMBDA(IQ+J),J=1,NQPL)
  652   FORMAT('  WHICH HAS ',6(A8,I3,3X))
!        WRITE(6,654)
  654   FORMAT(1X)
      ENDIF
      IQ=IQ+NQPL
      NT=NTERM(I)
C     FOR CASE 2, LVRTP=.TRUE. AND WE SKIP PROCESSING
      IF(LVRTP .OR. NT.EQ.0) GOTO 9000
      IF(NT.LT.0) GOTO 8800
      DO 8700 IT=1,NT
      IX=IX+1
      IF(IX.GT.IXMX) THEN
        WRITE(6,9101) IXMX
 9101   FORMAT(/'  *** POTENL.  DIMENSION IXMX EXCEEDED',I6)
        STOP
      ENDIF
      IF(NPOWER(IX).LT.0) GOTO 8200
      IF(NPOWER(IX).EQ.0) GOTO 8000
      WRITE(6,655) IX,NPOWER(IX)
  655 FORMAT(/'  * * * WARNING - POSITIVE EXPONENT OF R ILLEGAL',2I6/
     1   '  NEGATIVE OF SUPPLIED VALUE ASSUMED')
      IF(NPOWER(IX).GT.12 .OR. NPOWER(IX).LT.3) STOP
      NPOWER(IX)=-NPOWER(IX)
      GOTO 8200
C
 8000 IEX=IEX+1
      IF(IEX.GT.IEXMX) THEN
        WRITE(6,9201) IEXMX
 9201   FORMAT(/'  *** POTENL.  DIMENSION IEXMX EXCEEDED',I6)
        STOP
      ENDIF
      IF(E(IEX).LT.0.D0) GOTO 8100
      WRITE(6,656) E(IEX)
  656 FORMAT(/'  * * * WARNING - POTENTIAL CONTAINS INCREASING',
     1   ' EXPONENTIAL =',D16.8)
C
 8100 WRITE(6,657) A(IX), E(IEX)
  657 FORMAT(15X,D16.8,' * EXP(',F10.4,' * R )')
      IF(CFLAG.EQ.1) A(IX)=A(IX)*SQRT(4.D0*PI
     1   /DBLE(2*LAMBDA(IQ-NQPL+1)+1))
      GOTO 8700
C
 8200 WRITE(6,658) A(IX), NPOWER(IX)
  658 FORMAT(15X,D16.8,' * R **',I3)
      IF(CFLAG.EQ.1) A(IX)=A(IX)*SQRT(4.D0*PI
     1   /DBLE(2*LAMBDA(IQ-NQPL+1)+1))
      DO 8400 INPX=1,NPX
      IF(NPOWER(IX).EQ.NPUNI(INPX)) GOTO 8700
 8400 CONTINUE
 8500 NPX=NPX+1
      IF(NPX.GT.NPXMX) THEN
        WRITE(6,9301) NPXMX
 9301   FORMAT(/'  *** POTENL. DIMENSION NPXMX EXCEEDED',I6)
        STOP
      ENDIF
      NPUNI(NPX)=NPOWER(IX)
C
 8700 CONTINUE
      GOTO 9000
 8800 CALL VINIT(I,RM,EPSIL)
      IF(CFLAG.EQ.1) WRITE(6,662)
  662 FORMAT(' *** WARNING. SETTING CFLAG=1 HAS NO EFFECT',
     1   ' EXCEPT WHEN THE POTENTIAL IS SUPPLIED IN ARRAY A')
 9000 CONTINUE
!      WRITE(6,663) NPX
  663 FORMAT(/'  NUMBER OF UNIQUE POWERS =',I4)
C     IF(NPX.EQ.0) GOTO 9020   -- NOT REQUIRED IN FORTRAN 77
!      DO 9010 I=1,NPX
! 9010 WRITE(6,664) I, NPUNI(I)
!  664 FORMAT('  POWER',I3,' =',I4)
! 9020 CONTINUE
C
C     IF LAM HAS NOT YET BEEN FILLED, GET FROM LAMBDA
      IF (XLAM) GO TO 9050
      IF (MXLAM*NQPL.GT.MXLMB) GO TO 9500
      DO 9030 I=1,MXLAM*NQPL
 9030 LAM(I)=LAMBDA(I)
      XLAM=.TRUE.
C
C     COMMON RETURN POINT FOR ALL INITIALIZATIONS.
C     SET VALUES BACK IN CALLING PARAMETERS.
C
 9050 IF (XLAM) THEN 
      !WRITE(6,665) EPSIL,RM,MXLAM,NPOTL
	  ENDIF
  665 FORMAT(/'  POTENL PROCESSING FINISHED.'//
     1   '  ENERGY IN UNITS OF EPSILON =',F15.5,' CM-1'/
     2   '  R      IN UNITS OF RM      =',F15.5,' ANGSTROMS'//
     3   '  MXLAM =',I5/'  NPOTL =',I5)
C
      R=RM
      P(1)=EPSIL
      MPOTL=NPOTL
      MXLMB=MXLAM
      RETURN
C
C     ********** ERROR CONDITIONS **********
C
 9300 WRITE(6,9301) NDIM,MXDIM
 9306 FORMAT(/' *** POTENL. PROJECTED POTENTIAL HAS',I3,
     1       ' DIMENSIONS, BUT MXDIM=',I3)
      STOP
 9400 WRITE(6,9401) NPT,NPS,MXPT
 9401 FORMAT(/' *** POTENL. EITHER NPT OR NPS EXCEEDS MXPT'
     2      /'  NPT =',I6,'  NPS =',I6/'  MXPT=',I7)
C       WRITE(6,649) NPT,MXPT
      STOP
 9500 WRITE(6,9501) MXLMB,MXLAM
 9501 FORMAT(/' *** POTENL. DIMENSION OF EXTERNAL LAM ARRAY EXCEEDED'/
     1        '  SIZE PASSED FROM CALLING PROGRAM (MXLMB) =',I8/
     2        '  OFFENDING VALUE OF MXLAM =',I8)
      STOP
C
C     BELOW IS REACHED IF THERE WAS NOT ENOUGH ROOM IN THE X ARRAY TO
C       STORE THE PROJECTION COEFFS.  IF USING /MEMORY/...X, IT IS
C       POSSIBLE FOR THE CODE HERE TO OVERWRITE THE LAM ARRAY WITH
C       COEFFS.  HOWEVER, THE PROGRAM SHOULD THEN TERMINATE WHEN CHKSTR
C       IS CALLED FROM DRIVER AFTER RETURN FROM POTENL INITIALIZATION.
 9600 NREQ=MXLAM*(NPT+NPS)
      MXSTRT=MX+NREQ
      WRITE(6,9601) NPT,NPS,MXLAM,NREQ,MXSTRT,MXSTRT-IXNEXT+1
 9601 FORMAT(' *** POTENL. NOT ENOUGH ROOM FOR PROJECTION COEFFICIENTS'/
     1       '     REQUIRES (',I4,' +',I4,') * ',I4,' =',I8/
     2       '     OF',I8,' ORIGINALLY SUPPLIED IN X(), ONLY',I8,
     3       '  WERE AVAILABLE.')
      STOP
      END
      FUNCTION PLM(LIN,MIN,COSTH)
C
C     COMPUTES NORMALIZED ASSOC. LEGENDRE POLYNOMIALS BY RECURSION.
C     THE VALUES RETURNED ARE NORMALIZED FOR INTEGRATION OVER X
C     (I.E. INTEGRATION OVER COS THETA BUT NOT PHI).
C     NOTE THAT THE NORMALIZATION GIVES
C           PLM(L,0,1)=SQRT(L+0.5)
C           PLM(L,0,X)=SQRT(L+0.5) P(L,X)
C     FOR M.NE.0, THE VALUE RETURNED DIFFERS FROM THE USUAL
C           DEFINITION OF THE ASSOCIATED LEGENDRE POLYNOMIAL
C           (E.G. EDMONDS PAGES 23-24)
C           BY A FACTOR OF (-1)**M*SQRT(L+0.5)*SQRT((L-M)!/(L+M)!)
C     THUS THE SPHERICAL HARMONICS ARE
C          CLM = PLM * EXP(I*M*PHI) / SQRT(L+0.5)
C          YLM = PLM * EXP(I*M*PHI) / SQRT(2*PI)
C     THIS ROUTINE ALWAYS RETURNS THE VALUE FOR ABS(MIN); NOTE THAT
C          FOR MIN.LT.0 THIS VALUE SHOULD BE MULTIPLIED BY PARITY(MIN)
C
C     FUNCTION PM1(LIN,MIN,COSTH)
C     This routine appears to be much more stable for large l, m than
C       the routine from Nerf/ modified according to R.T Pack
C     It was obtained:
C     From: Marie-Lise Dubernet <mld@ipp-garching.mpg.de>
C     Date: Mon, 19 Jun 1995 12:48:11 +0200 (MET DST)
C     Some mods 27-28 June 95 by SG for speed and to accord w/ MOLSCAT 
C     Bugs fixed 21 Sept 95 (SG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C     CHECK FOR ABS(COSTH).LE.1.D0 ... 
      IF (ABS(COSTH).GT.1.D0) THEN
        WRITE(6,*) ' *** ILLEGAL ARGUMENT TO PLM. X =',COSTH
        STOP
      ENDIF
C     SAVE ARGUMENTS IN LOCAL VARIABLES
      L=LIN
      M=ABS(MIN)
      X=COSTH
C
C  IF M>L PLM=0 !
      IF(M.GT.L) THEN
        PLM=0.D0
        RETURN
      ENDIF
      LMAX=L
C
      IF (M.GT.0) GO TO 5
C  HERE FOR REGULAR LEGENDRE POLYNOMIALS
      PLM=1.D0
      PM2=0.D0
      XL=0.D0
      DO 2 L=1,LMAX
      XL=XL+1.D0
      PP=((2.D0*XL-1.D0)*X*PLM-(XL-1.D0)*PM2)/XL
      PM2=PLM
    2 PLM=PP
      GO TO 9000
C
C  HERE FOR ALEXANDER-LEGENDRE POLYNOMIALS
C
    5 IMAX=2*M
      RAT=1.D0
      AI=0.D0
      DO 6 I=2,IMAX,2
      AI=AI+2.D0
    6 RAT=RAT*((AI-1.D0)/AI)
C     Y=SIN(THETA)
      Y=SQRT(1.D0-X*X)
      PLM=SQRT(RAT)*(Y**M)
      PM2=0.D0
      LOW=M+1
      XL=LOW-1
      DO 10 L=LOW,LMAX
      XL=XL+1.D0
      AL=DBLE((L+M)*(L-M))
      AL=1.D0/AL
      AL2=(DBLE((L+M-1)*(L-M-1)))*AL
      AL=SQRT(AL)
      AL2=SQRT(AL2)
      PP=(2.D0*XL-1.D0)*X*PLM*AL-PM2*AL2
      PM2=PLM
   10 PLM=PP
      PLM=PLM*(-1d0)**mod(MIN,2)
C
C     CONVERT TO MOLSCAT'S IDIOSYNCRATIC NORMALIZATION
9000  PLM=PLM*SQRT(XL+0.5D0)
      RETURN
      END
      FUNCTION THRJ(F1,F2,F3,G1,G2,G3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     SMALL CHANGES 31 JUL 95 (SG)
      SAVE MUNG,X,Y
      PARAMETER (MXIX=302)
      DIMENSION X(MXIX),Y(MXIX)
      DATA MUNG/0/
      IF (MUNG.EQ.21) GO TO 69
      MUNG = 21
      X(1) = 0.D0
      DO 100 I = 1, MXIX-1
      A = I
      X(I+1) = LOG(A) +X(I)
      Y(I+1) = LOG(A)
  100 CONTINUE
   69 IF(F1-ABS(G1)) 1,13,13
   13 IF(F2-ABS(G2))1,14,14
   14 IF(F3-ABS(G3))1,15,15
   15 SUM=F1+F2+F3
      NSUM=SUM+.001D0
      IF(SUM-NSUM)2,2,1
    1 THRJ=0.D0
      RETURN
    2 IF(ABS(G1+G2+G3)-1.D-08)3,3,1
    3 IF(F1+F2-F3)1,4,4
    4 IF(F1+F3-F2)1,5,5
    5 IF(F2+F3-F1)1,6,6
    6 J1=2.D0*F3+2.001D0
      J2=F1+F2-F3+1.001D0
      J3=F1-F2+F3+1.001D0
      J4=-F1+F2+F3+1.001D0
      J5=F1+F2+F3+2.001D0
      J6=F1+G1+1.001D0
      J7=F1-G1+1.001D0
      J8=F2+G2+1.001D0
      J9=F2-G2+1.001D0
      J10=F3+G3+1.001D0
      J11=F3-G3+1.001D0
      IF(J5.GT.MXIX) THEN
        WRITE(6,601) J5,MXIX
  601   FORMAT(' *** DIMENSION ERROR IN THRJ - INDEX.GT.MXIX',2I5)
        STOP
      ENDIF
      R=0.5D0*(Y(J1)+X(J2)+X(J3)+X(J4)-X(J5)
     1+X(J6)+X(J7)+X(J8)+X(J9)+X(J10)+X(J11))
      SUM=0.D0
      F=-1
      KZ=-1
    7 KZ=KZ+1
      F=-F
      J1=KZ+1
      J2=F1+F2-F3-KZ+1.001D0
      IF(J2)20,20,8
    8 J3=F1-G1-KZ+1.001D0
      IF(J3)20,20,9
    9 J4=F2+G2-KZ+1.001D0
      IF(J4)20,20,10
   10 J5=F3-F2+G1+KZ+1.001D0
      IF(J5)7,7,11
   11 J6=F3-F1-G2+KZ+1.001D0
      IF(J6)7,7,12
   12 JMAX=MAX(J1,J2,J3,J4,J5,J6)
      IF(JMAX.GT.MXIX) THEN
        WRITE(6,601) JMAX,MXIX
        STOP
      ENDIF
      S=-(X(J1)+X(J2)+X(J3)+X(J4)+X(J5)+X(J6))
      SUM=SUM+F*EXP(R+S)
      GO TO 7
   20 INT=ABS(F1-F2-G3)+0.0001D0
      VAL=((-1.D0)**INT)*SUM/SQRT(2.D0*F3+1.D0)
      IF(ABS(VAL).LE.1.D-6) VAL=0.D0
      THRJ=VAL
      RETURN
      END
      SUBROUTINE GASLEG(N,Z,A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C *** ROUTINE TO GENERATE GAUSS-LEGENDRE POINTS/WEIGHTS
C *** TAKEN FROM AD VAN DER AVOIRD'S N2-N2 CODE  (SG 11/7/91)
C *** NEEDS FUNCTION ZBES
      DIMENSION P(301),PD(301),Z(1),A(1)
      DATA PI/3.14159 26535 89793 D0/
      IF (N.LE.300) GO TO 20
      WRITE (6,10)
   10 FORMAT (/10X,31H***** GASLEG  N TOO LARGE *****/)
      STOP
   20 NN=N+1
      IFIN=0
      IODD=0
      C=2.0D0/PI
      C=1.0D0-(C*C)
      IF (MOD(N,2).EQ.0) GO TO 30
      NKNT=(N-1)/2
      IODD=1
      GO TO 40
   30 NKNT=N/2
   40 K=1
      CHA=0.0D0
      CHB=0.0D0
      P(1)=1.0D0
      DN=N+0.50D0
      DN2=DN*DN
      DEN=SQRT(DN2+(C/4.0D0))
   50 BES=ZBES(K)
      X=COS(BES/DEN)
      PDX=1.0D0/(1.0D0-X*X)
   60 CONTINUE
      P(2)=X
      DO 70 I=3,NN
      IN=I-1
      IM=I-2
      P(I)=((2.0D0*IN-1.0D0)*X*P(IN)-IM*P(IM))/IN
      PD(I)=IN*PDX*(P(IN)-X*P(I))
   70 CONTINUE
      IF (IFIN.EQ.1) GO TO 100
      IF (ABS(P(NN)).LT.1.0D-12) GO TO 80
      X=X-(P(NN)/PD(NN))
      PDX=1.0D0/(1.0D0-X*X)
      GO TO 60
   80 Z(K)=X
      TA=N*P(N)
      TA=TA*TA
      A(K)=(2.0D0*(1.0D0-X*X))/TA
      CHA=CHA+2.0D0*A(K)
      Z2=Z(K)*Z(K)
      CHB=CHB+2.0D0*A(K)*Z2
      IF (K.EQ.NKNT) GO TO 90
      K=K+1
      GO TO 50
   90 CONTINUE
      IF (IODD.EQ.0) GO TO 110
      X=0.0D0
      K=NKNT+1
      Z(K)=X
      IFIN=1
      GO TO 60
  100 TA=N*P(N)
      TA=TA*TA
      A(K)=2.0D0/TA
      CHA=CHA+A(K)
  110 CONTINUE
      RETURN
      END
      FUNCTION YRR(L1,L2,L,CT1,CT2,DP)
C
C     BISPHERICAL HARMONIC ANGULAR FUNCTIONS FOR TWO DIATOMS
C     CT1, CT2 ARE COS(THETA-1) AND COS(THETA-2), AND
C          DP IS DELTA(PHI), I.E., PHI2-PHI1, IN RADIANS
C     CF. GREEN, JCP 62, 2271 (1975) APPENDIX.
C     N.B. P(L,M;X) THERE IS (2*PI)**-1/2 NORMALIZED P(L,M;X)
C          MOLSCAT PLM(L,M,CT) ROUTINE IS NORMALIZED ON CT, AND
C               PLM(L,0,1.D0)=SQRT((2L+1)/2) .
C          THUS, MUST MULT EACH PLM BY (2*PI)**-1/2
C
C     ODD  L1+L2+L  *NOT* ALLOWED; TRAPPED W/MESSAGE AND STOP
C
C     NEEDS ROUTINES THRJ(XJ1,XJ2,XJ3,XM1,XM2,XM3)
C                    PLM(L,M,COSTH)
C                    PARITY(J)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ODD
      DATA PI/3.14159 26535 89793 D0/
      ODD(I)=2*(I/2)-I.NE.0
C
      IF (ODD(L1+L2+L)) GO TO 9999
C
      XL1=L1
      XL2=L2
      XL=L
C     SQRT(4*PI) FROM Y(L,M,THETA=0), 2*PI FOR TWO PLM'S
      DEN=SQRT(4.D0*PI)*2.D0*PI
      FACT=((2.D0*XL+1.D0)/DEN)*(-1d0)**mod((L1+L2),2)
      MTOP=MIN(L1,L2)
      M=0
      XM=0.D0
      SUM=THRJ(XL1,XL2,XL,0.D0,0.D0,0.D0)*PLM(L1,0,CT1)*PLM(L2,0,CT2)
 2000 M=M+1
      IF (M.GT.MTOP) GO TO 3000
      XM=XM+1.D0
      SUM=SUM+2.D0*(-1d0)**mod(M,2)*THRJ(XL1,XL2,XL,XM,-XM,0.D0)*
     1             PLM(L1,M,CT1)*PLM(L2,M,CT2)*COS(XM*DP)
      GO TO 2000
 3000 YRR=FACT*SUM
      RETURN
 9999 WRITE(6,699) L1,L2,L
  699 FORMAT('0 YRR *** ERROR.  ODD ARGUMENTS NOT ALLOWED',3I5)
      STOP
      END
      SUBROUTINE GAUSHP(NN,X,A)
C     CALCULATES THE ZEROS, X(I), AND WEIGHTS, A(I), I=1,NN, FOR
C       GAUSS-HERMITE QUADRATURE.
C     Approximates the integral from -infinity to infinity f(x)*exp(-x**2)
C       by the sum(i=1,nn) w(i)*f(x(i)).
C     ADAPTED BY S. GREEN FROM STROUD AND SECREST GAUSSIAN QUADRATURE FORMULAS.
C       VERSION OF 18 APRIL 94; FIXED NN=1 BUG 10 MAR 95 (SG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXIT=15)
      DIMENSION X(NN),A(NN)
      DATA EPS/1.D-15/
C
      GAM(Y)=(((((((.035868343D0*Y-.193527818D0)*Y+.482199394D0)*Y-
     1         .756704078D0)*Y+.918206857D0)*Y-.897056937D0)*Y+
     2             .988205891D0)*Y-.577191652D0)*Y+1.D0
C
      IF (NN.LE.0) THEN
        WRITE(6,*) ' *** GAUSHP CALLED FOR ILLEGAL NPT=',NN
        STOP
      ELSEIF (NN.EQ.1) THEN
        WRITE(6,*) ' *** GAUSHP. WARNING, SINGLE POINT REQUESTED.'
        X(1)=0.D0
        A(1)=SQRT(ACOS(-1.D0))
        RETURN
      ELSE
        FN=NN
        N1=NN-1
        N2=(NN+1)/2
C       COMPUTE GAMMA FN BY HASTINGS APPROX; 0.LE.X.LE.70.
        Z=FN
        IF (Z.LE.0.D0 .OR. Z.GE.7.D1) THEN
          WRITE(6,600) Z
  600     FORMAT('  *** GAUSHP. CANNOT GET GAMMA FUNCTION FOR',F10.2)
          STOP
        ENDIF
        IF (Z.EQ.1.D0) THEN
          GAMMA=1.D0
          GO TO 20
        ELSEIF (Z.LT.1.D0) THEN
          GAMMA=GAM(Z)/Z
          GO TO 20
        ELSE
          ZA=1.D0
   10     Z=Z-1.D0
          IF (Z-1.D0) 13,11,12
   11     GAMMA=ZA
          GO TO 20
   12     ZA=ZA*Z
          GO TO 10
   13     GAMMA=ZA*GAM(Z)
          GO TO 20
        ENDIF
   20   CC=1.7724538509D0*GAMMA*(2.D0**(-N1))
        S=(2.D0*FN+1.D0)**(1.D0/6.D0)
        DO 100 I=1,N2
        IF (I.EQ.1) THEN
C         LARGEST ZERO
          XT=S**3-1.85575D0/S
          GO TO 50
        ELSEIF (I.EQ.2) THEN
C         SECOND ZERO
          XT=XT-1.14D0*FN**.426D0/XT
          GO TO 50
        ELSEIF (I.EQ.3) THEN
C         THIRD ZERO
          XT=1.86D0*XT-0.86D0*X(1)
          GO TO 50
        ELSEIF (I.EQ.4) THEN
C         FOURTH ZERO
          XT=1.91D0*XT-0.91D0*X(2)
          GO TO 50
        ELSE
C         ALL HIGHER ZERO'S
          XT=2.D0*XT-X(I-2)
        ENDIF
C
C       IMPROVE THE APPROXIMATE ROOT XT AND OBTAIN
C         DPN = DERIVATIVE OF H(N) AT XT;  PN1 = VALUE OF H(N-1) AT XT
   50   IT=0
   60   IT=IT+1
        IF (IT.GT.MXIT) THEN
          WRITE(6,*) ' *** GAUSHP FAILED TO CONVERGE. ITERATIONS ='
     1             ,MXIT
          STOP
        ENDIF
        CALL HRECUR(P,DP,PN1,XT,NN)
        D=P/DP
        XT=XT-D
        IF (ABS(D).GT.EPS) GO TO 60
        DPN=DP
        X(I)=XT
        A(I)=CC/(DPN*PN1)
        NI=NN-I+1
        X(NI)=-XT
  100   A(NI)=A(I)
      ENDIF
      RETURN
      END
      SUBROUTINE HERM(H,N,X)
C
C     SUBROUTINE TO GENERATE HERMITE POLYNOMIALS
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(N)
      P0=1.0D0
      H(1)=P0
      IF(N.LE.1) RETURN
      X2=X+X
      P1=X2
      H(2)=P1
      IF(N.LE.2) RETURN
      DO 100 K=3,N
      TEMP=X2*P1 - DBLE(K+K-4)*P0
      P0=P1
      P1=TEMP
      H(K)=P1
  100 CONTINUE
      RETURN
      END
      subroutine ssh(lmax,theta,phi)
c     computes symmetrized spherical harmonics
c     which for Ar-H2O are equivalent to real part of
c     the function Alm.
c
c     theta and phi in radians
c
      implicit real*8 (a-h,o-z)
      common/realm/ almre(0:50,0:50)
      common/factorial/ fac(0:40)
      dimension cosm(0:8)
      if(lmax.gt.50) then
        write(6,*) 'lmax gt 50'
        stop
      endif
      nmax=2*lmax
      if(nmax.gt.54) then
        write(6,*) 'nmax gt 40'
        stop
      endif
      call fct(nmax)
      x=cos(theta)
c...  Plm is Robert's program computing associated Legendre polynomials.
c...  Normalization was changed to standard,  i.e., P_l0(1) = 1.
      call xplm(almre,x,lmax)
      do m=0,lmax
        cosm(m)=cos(m*phi)
      enddo
      do l=0,lmax
c...    now we need only even m but if odd needed,  change the line below
        do m=0,l,2
c         write(6,*) l,m, almre(l,m)
          almre(l,m) = almre(l,m)*(-1)**(l+m)
     $                 *dsqrt(fac(l-m)/fac(l+m)/(2*l+1))
     $                 *cosm(m)
c         write(6,*) l,m, almre(l,m)
        enddo
      enddo
      return
      end 
        subroutine arh2osapt(iaa,r,theta,phi,energy)
c       subroutine arh2osapt(iaa,r,theta,phi,energy,tima,timb)
        implicit real*8 (a-h,o-z)
        logical first
        parameter (mxl=100)
        parameter (maxb=4*mxl,maxp=800)
        parameter (maxc=5000)
        dimension rpt(6)
        common/damp/ ldum(5,mxl),cdum(maxb),ndum
        common/exch/ lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1               idonex,exscale,lmaxex
        common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt,
     $               lmaxli
        common/dind/ cd(maxc),ci(maxc),ld(6,maxc),li(6,maxc),
     1               idisp,iind,lmaxi,lmaxd
        data a0 /0.529177249d0/
        data first /.true./
        data xkcal /627.51d0/
        data cm    /219474.63d0/
        data icount /0/
c
c       Modified version of subroutine computing the Ar-H2O potential.
c       The calls to Wormer's almre were replaced by a calculation of
c       spherical harmonics -- subroutine ssh.
c
c       INPUT:
c       ======
c       dimer geometry (R, theta, phi)   -- via header or read in
c       long-range coefficients          -- in files coefi.dat and coefd.dat
c       short-range optimized parameters -- in params
c
c       irpowex=1    now read in rdexch
c       irpowsp = 3  now read in rdlin
c       imode   = i  controls terms computed by potentot
c                 3  only asymptotics
c                 4  both short-range and asymptotics
c
c       Lines deactivated by c1 compute derviatives.
c
c       icount=icount+1
c       if((icount/100)*100 .eq. icount) write(6,*) 'icount=', icount
        pi = dacos(-1.d0)
        d2rad = pi/180.d0
c...    activate next two lines for stand alone program
c       write(6,*)'enter: i=1 or 2 for bohr/ang, R, theta, phi in deg'
c       read(5,*) iaa,r,theta,phi
        do j=1,6
          rpt(j)=0.0d0
        enddo
c...    program uses R in angstroms
        if(iaa.eq.1) rpt(1) = a0*r
        if(iaa.eq.2) rpt(1) = r
        rpt(2) = d2rad*theta
        rpt(3) = d2rad*phi
        if(first) then
          call rdmom    ! now superfluos call
          call rdcoef   ! read induction and dispersion coeffs
          call rdexch   ! read short-range exponential parms
          call rdlin    ! read short-range linear parms
          first=.false.
        endif
        ndum = nex
        ipow = 2
        do i=1,nex
         cdum(i) = cex(ipow*i-ipow+2)
         do k=1,5
          ldum(k,i) = lex(k,i)
         end do
        end do
c
c       compute table of A_lm functions.  There functions are
c       for this particular case identical to those produced by almre.
c
        lmax = max0(lmaxex,lmaxli,lmaxi,lmaxd)
c       write(6,*) 'lmax', lmax
c       call gclock(tim1)
        call ssh(lmax,rpt(2),rpt(3))
c       call gclock(tim2)
c       tima=tima+tim2-tim1
c
        imode = 4
c       call potentot(rpt,vex,vsp,valas,der,imode,timb)
        call potentot(rpt,vex,vsp,valas,der,imode)
c       write(6,'(a,3f20.10)') 'vex,vsp,valas',
c    $                        vex*cm/xkcal,vsp*cm/xkcal,valas*cm/xkcal
        tot = vsp + valas
c       write(6,*)'Total energy:',tot
        energy=tot*cm/xkcal
c       energy=tot
c       stop
        return
        end

c
c Read the multipole moment components
c
        subroutine rdmom
        implicit real*8 (a-h,o-z)
       parameter (mxl=100)
       parameter (maxb=4*mxl,maxp=800)
        common/moments/ qa(100,3), qb(100,3),la(maxb),ka(maxb),lb(maxb),
     1 kb(maxb),nmoma, nmomb
c
!        write(6,*)'RDmom entered'
c---- read the moments for molecule A
        open(unit=73,file='PES_H2OHe/moments.a',form='formatted')
c
        do i=1,1000
         read(73,*,END=100) la(i),ka(i),(qa(i,j),j=1,3)
        end do
 100    continue
        nmoma = i - 1
!        write(6,*)nmoma,' A moments read in:'
!        write(6,*)' L            SCF             MP2             MP3'
        do i=1,nmoma
!         write(6,'(2i3,3e16.7)') la(i),ka(i),(qa(i,j),j=1,3)
        end do
        close(3,STATUS='delete')
c---- read the moments for molecule B
        open(unit=73,file='PES_H2OHe/moments.b',form='formatted')
c
        do i=1,1000
         read(73,*,END=101) lb(i),kb(i),(qb(i,j),j=1,3)
        end do
 101    continue
        nmomb = i - 1
!        write(6,*)nmomb,' B moments read in:'
!        write(6,*)' L            SCF             MP2             MP3'
        do i=1,nmomb
!         write(6,'(2i3,3e16.7)') lb(i),kb(i),(qb(i,j),j=1,3)
        end do
        close(3,STATUS='delete')
c
        return
        end
c
c Read the dispersion ond induction coefficients.
c It is assumed that the induction coefficients are
c complete, i.e., that both A->B and B->A are included,
c with the proper phases after the induct calculation...
c
        subroutine rdcoef
        implicit real*8 (a-h,o-z)
        parameter (maxc=5000)
        common/dind/ cd(maxc),ci(maxc),ld(6,maxc),li(6,maxc),
     1 idisp,iind,lmaxi,lmaxd
c
!        write(6,*)'RDcoef entered'
        open(unit=71,file='PES_H2OHe/coefd.dat',form='formatted')
        open(unit=72,file='PES_H2OHe/coefi.dat',form='formatted')
c
        lmaxd=0
        nmin=1000
        nmax=0
        do i=1,100000
         read(71,*,end=100)(ld(j,i),j=1,6), c0,c1,ctot
c !!!! update !!!!
c        cd(i) = c0    ! KSz
         cd(i) = ctot  ! KSz
         lmaxd=max0(lmaxd,ld(1,i))
         nmin=min0(nmin,ld(6,i))
         nmax=max0(nmax,ld(6,i))
        end do
 100    continue
        if(nmin.lt.6 .or. lmax.gt.12) then
!          write(6,*) 'n out of range in rdcoef'
          stop
        endif
        idisp = i-1
!        write(6,*)idisp,' nonzero dispersion coefficients read in'
c
        lmaxi=0
        nmin=1000
        nmax=0
        do i=1,100000
         read(72,*,END=200)(li(j,i),j=1,6),c0,c1,ctot
c !!!! update !!!!
c        ci(i) = c0    ! KSz
         ci(i) = ctot  ! KSz
         lmaxi=max0(lmaxi,li(1,i))
         nmin=min0(nmin,li(6,i))
         nmax=max0(nmax,li(6,i))
        end do
 200    continue
        if(nmin.lt.6 .or. lmax.gt.12) then
!          write(6,*) 'n out of range in rdcoef'
          stop
        endif
        iind = i-1
!        write(6,*)iind,' nonzero induction coefficients read in'
!        write(6,*) 'lmax ind and disp:', lmaxi, lmaxd
c
        close(1)
        close(2)
        return
        end
c
c Subroutine for the calculation of the multipole
c part of the electrostatic energy for a given
c dimer conformation. The angles are expressed
c in radians. 
c
        subroutine elst(rpt,el)
        implicit real*8 (a-h,o-z)
        complex*16 a, alm
       parameter (mxl=100)
       parameter (maxb=4*mxl,maxp=800)
        dimension rrev(20), oa(3), ob(3), oc(2), rpt(6), el(20)
        common/factorial/ fac(0:40)
        common/moments/ qa(100,3), qb(100,3),la(maxb),ka(maxb),lb(maxb),
     1 kb(maxb),nmoma, nmomb
        common/realm/ almre(0:50,0:50)
        data Pi /3.1415926535897932D0/
        data efact /627.51d0/
        data a0 /0.529177249d0/
        data oa(1) /0.d0/, oc /0.d0,0.d0/
c
        r = rpt(1)
        oa(2) = rpt(2)
        oa(3) = rpt(3)
        ob(1) = rpt(4)
        ob(2) = rpt(5)
        ob(3) = rpt(6)
        rrev(1) = 1.d0/(R/a0)
        do i=2,20
         rrev(i) = rrev(i-1)*rrev(1)
        end do
c
         els = 0.d0
        do i=1,20
         el(i) = 0.d0
        end do
c
        do ia=1,nmoma
        do ib=1,nmomb
         phase = fac(2*la(ia)+2*lb(ib)+1)
         phase = phase/(fac(2*la(ia))*fac(2*lb(ib)))
         phase = (-1.d0)**la(ia) * dsqrt(phase)
         ll = la(ia) + lb(ib)
         rrr = rrev(ll+1)
c...     replace call to almre by substitution of precomputed value
c        aa  = almre(la(ia),ka(ia),lb(ib),kb(ib),ll,OA,OB,OC)
         if(ka(ia) .lt. 0) then
!           write(6,*) 'ka .lt. 0 in elst'
           stop
         endif
         aa  = almre(la(ia),ka(ia))
c calculate the product of multipole moments at the proper level
c (currently -- MP3-resp)
         qpr = qa(ia,1)*qb(ib,1) + qa(ia,1)*(qb(ib,2)+qb(ib,3))
         qpr = qpr + (qa(ia,2)+qa(ia,3))*qb(ib,1)
c limitation to R^-11 in electrostatics....
         if((ll+1).le.11)
c     1   el(ll+1) = el(ll+1) + phase*rrr*real(a)*qpr
     1   el(ll+1) = el(ll+1) + phase*rrr*aa*qpr
        end do
        end do
c
        do i=1,20
         el(i) = efact*el(i)
        end do
c
c That's all
c
        return
        end
c
c
c   Calculate the total damped asymptotics from elst and dispind..
c   th1, th2, phi in radians...., R in Angstroms.
c
        subroutine asymp(rpt,value,valder)
        implicit real*8 (a-h,o-z)
       parameter (mxl=100)
       parameter (maxb=4*mxl,maxp=800)
        dimension rpt(6),oa(3), ob(3), oc(2)
        dimension en(20), el(20), ei(20), ed(20)
      common/damp/ ldum(5,mxl),cdum(maxb),ndum
      common/realm/ almre(0:50,0:50)
      data oa(1) /0.d0/, oc /0.d0,0.d0/
c
        r = rpt(1)
        oa(2) = rpt(2)
        oa(3) = rpt(3)
        ob(1) = rpt(4)
        ob(2) = rpt(5)
        ob(3) = rpt(6)
c
c---- call the asymptotics procedures to be changed....
c
        call dispind(rpt,ed,ei)
c       call elst(rpt,el) ! KSz deacive for ArH2O
c        call shrtas(R,th1,th2,phi,srval)
c
c---- Compute the damping constant for a given geometry
c
        dump = 0.d0
        do i=1,ndum
         la = ldum(1,i)
         ka = ldum(2,i)
         lb = ldum(3,i)
         kb = ldum(4,i)
         l  = ldum(5,i)
c glamc changed into glam to test the real alm version...
c...     replace calls to almre by substitution of precomputed value
c        glam = almre(la,ka,lb,kb,l,oa,ob,oc)
         if(ka .lt. 0) then
!           write(6,*) 'ka .lt. 0 in asympt'
           stop
         endif
         glam = almre(la,ka) ! KSz
c -- symmetrize iif molecules identical...
         iperm=0
         if(iperm.eq.1) then
          iphase = (-1)**(la+lb)
c         glam = glam + iphase*almre(lb,kb,la,ka,l,oa,ob,oc)
          if(kb .lt. 0) then
!            write(6,*) 'kb .lt. 0 in asympt'
            stop
          endif
          glam = glam + iphase*almre(lb,kb)
         endif
c         glam = real(glamc)
         dump = dump - cdum(i)*glam
        end do
c
c--- Damping factor ready, proceed to the asymptotics...
c
c       do i=1,20
        do i=6,12
c        en(i) = el(i) + ed(i) + ei(i)
         en(i) = ed(i) + ei(i)
        end do
        value = 0.d0
        valder = 0.d0
        do i=6,12 ! KSz changed from 1,20
         ddd = d(i,dump,r)
         value = value + ddd*en(i)
c1     valder = valder + en(i)*(dd(i,dump,r)-i*ddd/r)
        end do
       return
       end
c
      function d(n,beta,r)
c
c     calculate the damping factor (small R correct)
c
      implicit real*8 (a-h,o-z)
      br=beta*r
      sum=1.0d0
      term=1.0d0
      ncn=n
      do i=1,ncn
        term=term*br/i
        sum=sum+term
      enddo
      d=1.0d0 - dexp(-br)*sum
c     in case of d --> 0 use
c     d=1.0d0 - dexp(-br)*sum = sum_m=ncn+1^\infty br^m/m!
      if(dabs(d).lt.1.0d-8) then
        d=0.0d0
        do i=ncn+1,1000
          term=term*br/i
          d=d+term
          if(term/d .lt. 1.0d-8) go to 111
        enddo
!        write(6,*) 'No convergence in d'
  111 continue
      d=d*dexp(-br)
      endif
!c     write(6,'(i4,2f10.5,e20.10)') n,beta,r,d
      return
      end
c
      function dd(n,b,r)
      implicit real*8 (a-h,o-z)
      common/factorial/ f(0:40)
      br = b*r
      dd = b*dexp(-br)*(br)**n/f(n)
      return
      end
c
c Subroutine for the calculation of the multipole
c part of the dispersion and induction energies for a given
c dimer conformation. 
c
c       Ar-H2O version:
c       *** NOTICE ***
c       For Ar-H2O C_n^lm = C_n^l,-m,  however,  Polcor suite
c       includes both types of coefficients in output.
c       To avoid calculation of Alm for negative m we use
c       A_lm = A_l,-m for this symmetry.
c
        subroutine dispind(rpt,eld,eli)
        implicit real*8 (a-h,o-z)
        parameter (maxc=5000)
        dimension rr(20),oa(3),ob(3),oc(2), rpt(6), eld(2), eli(20)
        complex*16 a, alm
c--- common/dind/ contains dispersion and induction coefs.
        common/dind/ cd(maxc),ci(maxc),ld(6,maxc),li(6,maxc),
     1               idisp,iind
        common/realm/ almre(0:50,0:50)
        data Pi /3.1415926535897932D0/
        data a0 /0.529177249d0/
        data efact /627.51d0/        
        data oa(1) /0.d0/, oc /0.d0,0.d0/
c
        r = rpt(1)
        oa(2) = rpt(2)
        oa(3) = rpt(3)
        ob(1) = rpt(4)
        ob(2) = rpt(5)
        ob(3) = rpt(6)
        rrev = 1.d0/(R/a0)
        rr(1) = rrev
        do i=2,12
         rr(i) = rr(i-1)*rrev
        end do
        do i=1,20
         eld(i) = 0.d0
         eli(i) = 0.d0
        end do
c
        do i=1,idisp
         la = ld(1,i)
         ka = ld(2,i)
         lb = ld(3,i)
         kb = ld(4,i)
         l  = ld(5,i)
         n  = ld(6,i)
c...     replace calls to almre by substitution of precomputed value
c        aa = almre(la,ka,lb,kb,l,oa,ob,oc)
         aa = almre(la,iabs(ka)) ! KSz: notice iabs.
c         eld(n) = eld(n) + cd(i)*rr(n)*real(a)
         eld(n) = eld(n) + cd(i)*rr(n)*aa
        end do
c
        do i=1,iind
         la = li(1,i)
         ka = li(2,i)
         lb = li(3,i)
         kb = li(4,i)
         l  = li(5,i)
         n  = li(6,i)
c        aa = almre(la,ka,lb,kb,l,oa,ob,oc)
         aa = almre(la,iabs(ka)) ! KSz: notice iabs.
c         eli(n) = eli(n) + ci(i)*rr(n)*real(a)
         eli(n) = eli(n) + ci(i)*rr(n)*aa
        end do
c       do i=1,20
        do i=6,12
         eli(i) = -efact*eli(i)
         eld(i) = -efact*eld(i)
        end do
c
c That's all
c
        return
        end
c
c  A short subroutine to calculate the total interaction
c  potential from the exchange, "spherical", and
c  asymptotic parts...
c
        subroutine potentot(rpt,vex,vsp,valas,der,imode)
c       subroutine potentot(rpt,vex,vsp,valas,der,imode,timb)
        implicit real*8 (a-h,o-z)
        complex*16 glamc, alm
       parameter (mxl=100)
       parameter (maxb=4*mxl,maxp=800)
        dimension rr(10), rpt(6), oa(3), ob(3), oc(2)
      common/exch/lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1 idonex,exscale
      common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt
      common/realm/ almre(0:50,0:50)
      data xkcal /627.51d0/
      data cm    /219474.63d0/
      data oa(1) /0.d0/, oc /0.d0,0.d0/
c
        r = rpt(1)
        oa(2) = rpt(2)
        oa(3) = rpt(3)
        ob(1) = rpt(4)
        ob(2) = rpt(5)
        ob(3) = rpt(6)
        vex = 0.d0
        vsp = 0.d0
        valas = 0.d0
        if(imode.ne.3) then
        rr(1) = 1.d0
        do i=2,max(irpowex,irpowsp)+1
         rr(i) = rr(i-1)*r
        end do
c---- Compute the exchange part
        ipow = irpowex+1
c       write(6,*) 'ipow:', ipow
c       write(6,*) 'iexback:', iexback
        rrev = r**(-iexback)
        damp = 0.d0
        do i=1,nex
         la = lex(1,i)
         ka = lex(2,i)
         lb = lex(3,i)
         kb = lex(4,i)
         l  = lex(5,i)
c glamc changed into glam to test the real alm version...
c...     replace calls to almre by substitution of precomputed value
c        glam = almre(la,ka,lb,kb,l,oa,ob,oc)
         if(ka .lt. 0) then
!           write(6,*) 'ka .lt. 0 in potentot'
           stop
         endif
         glam = almre(la,ka)
c --- symmetrize if molecules identical...
c        write(6,*) 'iperm:', iperm
         iperm=0
         if(iperm.eq.1) then
          iphase = (-1)**(la+lb)
c         glam = glam + iphase*almre(lb,kb,la,ka,l,oa,ob,oc)
          if(kb .lt. 0) then
            write(6,*) 'kb .lt. 0 in potentot'
            stop
          endif
          glam = glam + iphase*almre(lb,kb)
         endif
c         glam = real(glamc)
c1       damp = damp + glam*cex(2*i)
         do k=1,ipow
         vex = vex + glam*cex(ipow*i-ipow+k)*rr(k)*rrev
c        write(6,'(2i2,4f16.8)') i,k,glam,cex(ipow*i-ipow+k),
c    $                 rr(k),vex
         end do
        end do
        vex = dexp(vex)
        if(imode.gt.1) then
c---- Compute the "spherical" part
        ipow = irpowsp + 1
c       write(6,*) 'ipow:', ipow
        rrev = r**(-ispback)
        rrev1 = rrev/r
        vsp = 0.d0
        vsp1 = 0.d0
        do i=1,nsp
         la = lsp(1,i)
         ka = lsp(2,i)
         lb = lsp(3,i)
         kb = lsp(4,i)
         l  = lsp(5,i)
c glamc changed into glam to test the real alm version...
c        glam = almre(la,ka,lb,kb,l,oa,ob,oc)
         if(ka .lt. 0) then
           write(6,*) 'ka .lt. 0 in potentot'
           stop
         endif
         glam = almre(la,ka)
c --- symmetrize if molecules identical....
         iperm=0
         if(iperm.eq.1) then
          iphase = (-1)**(la+lb)
c         glam = glam + iphase*almre(lb,kb,la,ka,l,oa,ob,oc)
          if(kb .lt. 0) then
            write(6,*) 'kb .lt. 0 in potentot'
            stop
          endif
          glam = glam + iphase*almre(lb,kb)
         endif
c         glam = real(glamc)
         do k=1,ipow
c---- skip dividing by r when done with experiments, 
c---- update gradient if proved successful
         vsp = vsp + glam*csp(ipow*i-ipow+k)*rr(k)*rrev
c        write(6,'(2i2,4f16.8)') i,k,glam,csp(ipow*i-ipow+k)*cm/xkcal,
c    $                 rr(k),vsp*cm/xkcal
c1       vsp1 = vsp1+ (k-ispback-1)*glam*csp(ipow*i-ipow+k)*rr(k)*rrev1
         end do
        end do
        vsp = vex*vsp
c1      vsp1 = vsp1*vex + damp*vsp
        endif
        endif
c----- Compute the asymptotics...
c       call gclock(tim1)
        if(imode.ge.3)
     1  call asymp(rpt,valas,valdr)
c       call gclock(tim2)
c       timb=timb+tim2-tim1
c1      der = vsp1 + valdr
        return
        end
c
      subroutine rdexch
c
c     reads in the parameters of the expansion of exponential
c      
      implicit real*8 (a-h,o-z)
      parameter (mxl=100)
      parameter (maxb=4*mxl,maxp=800)
      common/exch/lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1           idonex,exscale,lmaxex
c
        open(unit=77,file='PES_H2OHe/params.dat',form='formatted')
c
c       read nex     - number of angular functions in expansion of exponent
c            irpowex - largest power of R in exponent
c
        read(77,*) nex,irpowex
        lmaxex=0
        do i=1,nex
         read(77,*)num,(lex(j,i),j=1,5)
         lmaxex=max0(lmaxex,lex(1,i))
        end do
        do i=1,(irpowex+1)*nex
         read(77,*) num, cex(i)
        end do
!        write(6,*)'The exchange part basis and coefs:'
        do i=1,nex
!         write(6,10)i,(lex(j,i),j=1,5)
        end do
        do i=1,(irpowex+1)*nex
!         write(6,*) i,cex(i)
        end do
 10     format(6i4)
       return
       end
c
      subroutine rdlin
c
c     reads in the parameters of the expansion of linear factor
c
      implicit real*8 (a-h,o-z)
      parameter (mxl=100)
      parameter (maxb=4*mxl,maxp=800)
      common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt,
     $             lmaxli
c
      read(77,*) nsp,irpowsp
!      write(6,*) 'nsp:', nsp
      lmaxli=0
      do k=1,irpowsp+1
!      write(6,'(A,I1)') 'Parameters at R^',k-1
      do i=1,nsp
       read(77,*) (lsp(j,i),j=1,5),csp((irpowsp+1)*i-irpowsp-1+k)
       lmaxli=max0(lmaxli,lsp(1,i))
!       write(6,'(6i4,e20.10)') i, (lsp(j,i),j=1,5),
!     $                         csp((irpowsp+1)*i-irpowsp-1+k)
      end do
      end do
      return
      end
      SUBROUTINE HRECUR(PN,DPN,PN1,X,NN)
C     SG: ADAPTED FROM STROUD AND SECREST, GAUSSIAN QUADRATURE FORMULAS  GREEN.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      P1=1.D0
      P=X
      DP1=0.D0
      DP=1.D0
      DO 1 J=2,NN
      FJ=J
      FJ2=(FJ-1.D0)/2.D0
      Q=X*P-FJ2*P1
      DQ=X*DP+P-FJ2*DP1
      P1=P
      P=Q
      DP1=DP
 1    DP=DQ
      PN=P
      DPN=DP
      PN1=P1
      RETURN
      END
      subroutine vinit(i,rm,epsil)
      implicit real*8 (a-h,o-z)
c     dummy call for us
      return
      end
      subroutine vstar(maxlm,lambda,iterm,r,energy)
c     subroutine vstar(maxlm,lambda,iterm,r,energy,vsp,erminusn)
c       subroutine arh2osapt(iaa,r,theta,phi,energy)
c       subroutine arh2osapt(iaa,r,theta,phi,energy,tima,timb)
        implicit real*8 (a-h,o-z)
        logical first
        parameter (mxl=100)
        parameter (maxb=4*mxl,maxp=800)
        parameter (maxc=5000)
        dimension rpt(6)
        dimension lambda(maxlm)
        common/damp/ ldum(5,mxl),cdum(maxb),ndum
        common/exch/ lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1               idonex,exscale,lmaxex
        common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt,
     $               lmaxli
        common/dind/ cd(maxc),ci(maxc),ld(6,maxc),li(6,maxc),
     1               idisp,iind,lmaxi,lmaxd
        common/dind2/cnlm(0:6,0:8,0:8),
     $               cdnlm(0:6,0:8,0:8),
     $               cinlm(0:6,0:8,0:8),
     $               nmaxd,nmaxi,nmax
        data a0 /0.529177249d0/
        data first /.true./
        data xkcal /627.51d0/
        data cm    /219474.63d0/
        data icount /0/
c
c       Modified version of subroutine computing the Ar-H2O potential.
c       Comuputes just the V_lm (R) value.  Reads the same input as potenssh.
c
c       INPUT:
c       ======
c       dimer geometry (R only now)      -- via header
c       long-range coefficients          -- in files coefi.dat and coefd.dat
c       short-range optimized parameters -- in params
c
c       irpowex=1    now read in rdexch
c       irpowsp = 3  now read in rdlin
c       imode   = i  controls terms computed by potentot
c                 3  only asymptotics
c                 4  both short-range and asymptotics
c
c       icount=icount+1
c       if((icount/100)*100 .eq. icount) write(6,*) 'icount=', icount
        pi = dacos(-1.d0)
        d2rad = pi/180.d0
        do j=1,6
          rpt(j)=0.0d0
        enddo
c...    program uses R in angstroms
        rpt(1)=r
        if(first) then
          call rdcoefX   ! read induction and dispersion coeffs
          call rdexchX   ! read short-range exponential parms
          call rdlinX    ! read short-range linear parms
c         consistency check and regroup disp and ind coefs
          do n=0,6
            do l=0,8
              do m=0,8
                cnlm(n,l,m) = 0.d0
                cdnlm(n,l,m) = 0.d0
                cinlm(n,l,m) = 0.d0
              enddo
            enddo
          enddo
          nmaxd=0
          do i=1,idisp
            l=ld(1,i)
            m=iabs(ld(2,i))
            n=ld(6,i)-6
            nmaxd=max0(nmaxd,n)
            cdnlm(n,l,m) = cd(i)
          enddo
c...      Is there a C_nlm for each l,m required by molscat?
          do i=1,maxlm
            l=lambda(2*i-1)
            m=lambda(2*i)
            izero = 0
            do n=0,nmaxd
              if(cdnlm(n,l,m).ne.0.d0) izero = 1
            enddo
!            if(izero.eq.0) 
!     $        write(6,*) 'No nonzero dispersion coeff, i,l,m:',i,l,m
!            if(izero.eq.1)
!     $        write(6,'(i1,i2,7f11.3)') l,m,(cdnlm(n,l,m),n=0,nmaxd)
          enddo
c...      Is there a molscat function for each nonzero C_nlm?
          do l=0,8
            do m=0,8
              izero = 0
              do n=0,6
                if( cdnlm(n,l,m) .ne. 0.d0) izero=1
              enddo
              if(izero.eq.1) then
                ilam=0
                do i=1,maxlm
                  if(l.eq.lambda(2*i-1) .and. m.eq.lambda(2*i)) ilam=1
                enddo
!                if(ilam.eq.0) write(6,*) 'No molscat function for l,m:',
!     $                       l,m
              endif
            enddo
          enddo
          nmaxi=0
          do i=1,iind
            l=li(1,i)
            m=iabs(li(2,i))
            n=li(6,i)-6
            nmaxi=max0(nmaxi,n)
            cinlm(n,l,m) = ci(i)
          enddo
c...      Is there a C_nlm for each l,m required by molscat?
          do i=1,maxlm
            l=lambda(2*i-1)
            m=lambda(2*i)
            izero = 0
            do n=0,nmaxi
              if(cinlm(n,l,m).ne.0.d0) izero = 1
            enddo
!            if(izero.eq.0)
!     $        write(6,*) 'No nonzero dispersion coeff, i,l,m:',i,l,m
!            if(izero.eq.1)
!     $        write(6,'(i1,i2,7f11.3)') l,m,(cinlm(n,l,m),n=0,nmaxi)
          enddo
c...      Is there a molscat function for each nonzero C_nlm?
          do l=0,8
            do m=0,8
              izero = 0
              do n=0,6
                if( cinlm(n,l,m) .ne. 0.d0) izero=1
              enddo
              if(izero.eq.1) then
                ilam=0
                do i=1,maxlm
                  if(l.eq.lambda(2*i-1) .and. m.eq.lambda(2*i)) ilam=1
                enddo
!                if(ilam.eq.0) write(6,*) 'No molscat function for l,m:',
!     $                       l,m
              endif
            enddo
          enddo
c...      Add long-range constants
          nmax=max0(nmaxi,nmaxd)
          do n=0,nmax
            do l=0,8
              do m=0,8
c...            C's are in hartees*bohr^n,  convert here to kcal/mol
                cnlm(n,l,m) = (cdnlm(n,l,m) + cinlm(n,l,m))*xkcal
c...            ***NOTICE*** Polcor prints C_m and C_-m which are equal
                if(m.ne.0) cnlm(n,l,m)=2.0d0*cnlm(n,l,m)
              enddo
            enddo
          enddo
c...      Now check short-range
!          if(maxlm.ne.nsp) write(6,*) 'Different number of terms ',
!     $                                'in short-range than in molscat',
!     $                                ' nsp, maxlm', nsp,maxlm
          if(maxlm.lt.nsp) then
            write(6,*) 'maxlm must be larger or equal nsp'
            stop
          endif
c...      Do l,m match?
          do i=1,maxlm
            l=lambda(2*i-1)
            m=lambda(2*i)
            if(l.ne.lsp(1,i) .or. m.ne. lsp(2,i))
     $        write(6,*) 'Short-range term is zero for ilm:',i,l,m,
     $                   ' OR there is a mismatch ****'
          enddo
          first=.false.
        endif
        ndum = nex
        ipow = 2
        do i=1,nex
         cdum(i) = cex(ipow*i-ipow+2)
         do k=1,5
          ldum(k,i) = lex(k,i)
         end do
        end do
        l=lambda(2*iterm-1)
        m=lambda(2*iterm)
        call potentotX(rpt,iterm,l,m,energy,vsp,erminusn)
        energy=energy*cm/xkcal
c...    Multiply for the factor taking care of the difference
c       between Re A_lm used by us and [Ylm + Yl,-m]/(1+delta_m0)
c...    used by molscat
        energy=energy*(-1)**l*dsqrt(4.0d0*pi)/2.0d0/(2*l+1)
        if(m.eq.0) energy=2.0d0*energy
c       vsp=vsp*cm/xkcal
c       erminusn=erminusn*cm/xkcal
        return
        end

c
c Read the dispersion ond induction coefficients.
c It is assumed that the induction coefficients are
c complete, i.e., that both A->B and B->A are included,
c with the proper phases after the induct calculation...
c
        subroutine rdcoefX
        implicit real*8 (a-h,o-z)
        parameter (maxc=5000)
        common/dind/ cd(maxc),ci(maxc),ld(6,maxc),li(6,maxc),
     1 idisp,iind,lmaxi,lmaxd
c
!        write(6,*)'RDcoef entered'
        open(unit=71,file='PES_H2OHe/coefd.dat',form='formatted')
        open(unit=72,file='PES_H2OHe/coefi.dat',form='formatted')
c
        lmaxd=0
        nmin=1000
        nmax=0
        do i=1,100000
         read(71,*,end=100)(ld(j,i),j=1,6), c0,c1,ctot
         cd(i) = ctot  ! KSz
         lmaxd=max0(lmaxd,ld(1,i))
         nmin=min0(nmin,ld(6,i))
         nmax=max0(nmax,ld(6,i))
        end do
 100    continue
        if(nmin.lt.6 .or. lmaxd.gt.12) then
          write(6,*) 'n out of range in rdcoef'
          stop
        endif
        idisp = i-1
!        write(6,*)idisp,' nonzero dispersion coefficients read in'
c
        lmaxi=0
        nmin=1000
        nmax=0
        do i=1,100000
         read(72,*,END=200)(li(j,i),j=1,6),c0,c1,ctot
         ci(i) = ctot  ! KSz
         lmaxi=max0(lmaxi,li(1,i))
         nmin=min0(nmin,li(6,i))
         nmax=max0(nmax,li(6,i))
        end do
 200    continue
        if(nmin.lt.6 .or. lmaxi.gt.12) then
          write(6,*) 'n out of range in rdcoef'
          stop
        endif
        iind = i-1
!        write(6,*)iind,' nonzero induction coefficients read in'
!        write(6,*) 'lmax ind and disp:', lmaxi, lmaxd
c
        close(1)
        close(2)
        return
        end
c
      function dX(n,beta,r)
c
c     calculate the damping factor (small R correct)
c
      implicit real*8 (a-h,o-z)
      br=beta*r
      sum=1.0d0
      term=1.0d0
      ncn=n
      do i=1,ncn
        term=term*br/i
        sum=sum+term
      enddo
      dX=1.0d0 - dexp(-br)*sum
c     in case of d --> 0 use
c     d=1.0d0 - dexp(-br)*sum = sum_m=ncn+1^\infty br^m/m!
      if(dabs(d).lt.1.0d-8) then
        d=0.0d0
        do i=ncn+1,1000
          term=term*br/i
          d=d+term
          if(term/d .lt. 1.0d-8) go to 111
        enddo
!        write(6,*) 'No convergence in d'
  111 continue
      dX=d*dexp(-br)
      endif
c     write(6,'(i4,2f10.5,e20.10)') n,beta,r,d
      return
      end
c
c  A short subroutine to calculate the total interaction
c  potential from the exchange, "spherical", and
c  asymptotic parts...
c
      subroutine potentotX(rpt,iterm,l,m,energy,vsp,erminusn)
      implicit real*8 (a-h,o-z)
      parameter (mxl=100)
      parameter (maxb=4*mxl,maxp=800)
      dimension rr(20), rpt(6), oa(3), ob(3), oc(2)
      common/exch/lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1            idonex,exscale
      common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt
      common/realm/ almre(0:50,0:50)
      common/dind2/cnlm(0:6,0:8,0:8),
     $             cdnlm(0:6,0:8,0:8),
     $             cinlm(0:6,0:8,0:8),
     $             nmaxd,nmaxi,nmax
      data xkcal /627.51d0/
      data cm    /219474.63d0/
      data a0 /0.529177249d0/
      data oa(1) /0.d0/, oc /0.d0,0.d0/
c
      r = rpt(1)
      vex = 0.d0
      vsp = 0.d0
      ipow = irpowex+1
c---- The same beta is used for short-range and for damping:
c     ipow should be 2 == R^1
      betadamp = -cex(ipow)
c...  Skip over short-range part if its angular expansion is shorter
c...  than the angular expansion of the asymptotics
      if(iterm.gt.nsp) go to 111
c
      rr(1) = 1.d0
      do i=2,max(irpowex,irpowsp)+1
         rr(i) = rr(i-1)*r
      end do
c---- Compute the exponential
      i=1 ! Exponent is independent of angles,  thus only first (constant) Alm
      do k=1,ipow
         vex = vex + cex(ipow*i-ipow+k)*rr(k)
      end do
      vex = dexp(vex)
c---- Compute the linear possitive power of R part
      ipow = irpowsp + 1
      vsp = 0.d0
      i=iterm ! V_i(R) for ith angular function called by molscat
      do k=1,ipow
         vsp = vsp + csp(ipow*i-ipow+k)*rr(k)
      end do
      vsp = vex*vsp
  111 continue
c---- Compute the asymptotics...
      rrev = 1.d0/(r/a0)
      rr(1) = rrev
      do i=2,12
         rr(i) = rr(i-1)*rrev
      end do
c
      erminusn=0.0d0
      do n=0,nmax
        erminusn=erminusn-cnlm(n,l,m)*rr(n+6)*dX(n+6,betadamp,r)
c       write(6,'(3e12.4)') cnlm(n,l,m),rr(n+6),dX(n+6,betadamp,r)
      enddo
c     write(6,*) '*** nmax,l,m,erminusn', nmax,l,m,erminusn
      energy=vsp+erminusn
c
      return
      end
c
      subroutine rdexchX
c
c     reads in the parameters of the expansion of exponential
c      
      implicit real*8 (a-h,o-z)
      parameter (mxl=100)
      parameter (maxb=4*mxl,maxp=800)
      common/exch/lex(5,mxl),cex(maxb),nex,irpowex,iwex,iexback,igrx,
     1           idonex,exscale,lmaxex
c
        open(unit=77,file='PES_H2OHe/params.dat',form='formatted')
c
c       read nex     - number of angular functions in expansion of exponent
c            irpowex - largest power of R in exponent
c
        read(77,*) nex,irpowex
        lmaxex=0
        do i=1,nex
         read(77,*)num,(lex(j,i),j=1,5)
         lmaxex=max0(lmaxex,lex(1,i))
        end do
        do i=1,(irpowex+1)*nex
         read(77,*) num, cex(i)
        end do
!        write(6,*)'The exchange part basis and coefs:'
        do i=1,nex
!         write(6,10)i,(lex(j,i),j=1,5)
        end do
        do i=1,(irpowex+1)*nex
!         write(6,*) i,cex(i)
        end do
 10     format(6i4)
       return
       end
c
      subroutine rdlinX
c
c     reads in the parameters of the expansion of linear factor
c
      implicit real*8 (a-h,o-z)
      parameter (mxl=100)
      parameter (maxb=4*mxl,maxp=800)
      common/spher/lsp(5,mxl),csp(maxb),nsp,irpowsp,iwsp,ispback,igrt,
     $             lmaxli
c
      read(77,*) nsp,irpowsp
!      write(6,*) 'nsp:', nsp
      lmaxli=0
      do k=1,irpowsp+1
      write(6,'(A,I1)') 'Parameters at R^',k-1
      do i=1,nsp
       read(77,*) (lsp(j,i),j=1,5),csp((irpowsp+1)*i-irpowsp-1+k)
       lmaxli=max0(lmaxli,lsp(1,i))
!       write(6,'(6i4,e20.10)') i, (lsp(j,i),j=1,5),
!     $                         csp((irpowsp+1)*i-irpowsp-1+k)
      end do
      end do
      return
      end
      SUBROUTINE VRTP(IDERIV,R,P)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	dimension parm(14)
      DIMENSION  P(1)
C
C     *****************************************************************
C     *  IF POTENTIAL IS --NOT-- EXPANDED IN ANGULAR FUNCTIONS, I.E., *
C     *    MXSYM.LE.0, THIS ROUTINE MUST SUPPLY THE POTENTIAL AND     *
C     *    ITS 1ST AND 2ND DERIVATIVE (IDERIV=0,1,2, RESPECTIVELY).   *
C     *  EVALUATE POTENTIAL AT ANGLES SPECIFIED IN COMMON /ANGLES/    *
C     *    COSANG(1) IS THETA, COSANG(2) IS PHI, COSANG(3) RESERVED   *
C     *    FOR ITYPE=3.                                               *
C     *  SINCE IHOMO/ICNSYM CANNOT BE DETERMINED BY IOSBGP WITHOUT    *
C     *    ANGULAR EXPANSION TERMS, THEY MAY BE SET HERE IN /ANGLES/; *
C     *    IF NOT SET, DEFAULT VALUES WILL BE IHOMO=ICNSYM=1          *
C     *  POTENTIAL, RETURNED IN P(1), MUST BE MULTIPLIED BY 'FACTOR'  *
C     *    (SET IN IOSBIN AND PASSED IN /ANGLES/) TO COUNTER LOWEST   *
C     *    ANGULAR FUNCTION (ITYPE DEPENDENT) WHICH MULTIPLIES IT.    *
C     *  INITIALIZATION CALL (IDERIV.LT.0) MAY SET AND/OR USE         *
C     *      RM=R AND EPSIL=P(1)                                      *
C     *****************************************************************
C
C      COMMON /ANGLES/COSANG(3),FACTOR,IHOMO,ICNSYM
      COMMON/ANGLES/COSANG(7),FACTOR,IHOMO,ICNSYM,IHOMO2,ICNSY2
	Pi=dacos(-1.d0)
	  write(*,*)
C
      IF (IDERIV.LT.0) THEN
        ICNSYM=2
        IHOMO=1
        R=1.d0
        P(1)=1.d0
c        print *, 'This program uses the SAPT Ar + H2O potential.'
c TEST
        iaa=2
        rr=2.962d0
        theta=0.d0
        phi=0.d0
        call arh2osapt(iaa,rr,theta,phi,ener)
!        write(6,*) 'TEST',rr,theta,phi,ener
c TEST
        RETURN
      ENDIF

      THETA=ACOS(COSANG(1))
      PHI=COSANG(2)

c **** Maybe I need to change angle units:******12/9/96******
	THETA=180.d0*THETA/Pi
	PHI=180.d0*PHI/Pi
c
      IF (IDERIV.GE.1) then
        print *, 'ideriv > 0 '
        STOP
      endif

c     ENER = SAPTAW(R,THETA,PHI,parm)
      iaa=2
c     Now r -- AA, angles -- deg.,  energy -- cm
      call arh2osapt(iaa,r,theta,phi,ener)
      P(1)= ENER
c      rm = 0.52917706D0
c      write(*,10)r/rm,theta,phi,ener
c 10   format(1x,f9.4,f9.4,f9.4,e15.7)

      RETURN
      END

      SUBROUTINE GAUSSP(A,B,NPT,XPT,WHT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XPT(NPT),WHT(NPT)
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C     THIS ROUTINE SETS UP ABSCISSAE AND WEIGHTS FOR NPT-POINT        *
C       GAUSS-LEGENDRE INTEGRATION IN THE INTERVAL (A,B).             *
C                                                                     *
C     ON RETURN, THE FUNCTION TO BE INTEGRATED SHOULD BE EVALUATED    *
C       AT THE POINTS XPT(I). INTEGRAL = SUM(I=1,NPT) F(XPT(I))*WHT(I)*
C                                                                     *
C     THIS VERSION (SG 11/7/91) CALCULATES POINTS/WEIGHTS FROM        *
C       GASLEG/ZBES CODE OF AD VAN DER AVOIRD                         *
C     DOES ANY NUMBER OF PTS FROM 1 TO MXPT, WHERE LIMIT IS FROM      *
C       DIMENSION STATEMENTS IN GASLEG (P,PD AT LEAST (MXPT+1) )      *
C         AND HERE W,X DIMENSIONED AT LEAST  ((MXPT+1)/2)             *
C                                                                     *
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      DIMENSION X(128),W(128)
      DATA MXPT/256/
C
      T1=(B-A)/2.D0
      T2=(B+A)/2
      IF (NPT-1)  9999,9998,9997
 9997 IF (NPT.LE.MXPT) GO TO 3100
!      WRITE(6,601)  NPT,MXPT
  601 FORMAT('0 * * * WARNING.  GAUSS-LEGENDRE NPT =',I6,'  REDUCED TO',
     1   I4)
      NPT=MXPT
 3100 CALL GASLEG(NPT,X,W)
      N2=(NPT+1)/2
      I1=1
      I2=NPT
      IC=1
      DO 2000 I=1,N2
      XPT(I1)=-X(IC)*T1+T2
      XPT(I2)=X(IC)*T1+T2
      WHT(I1)=W(IC)*T1
      WHT(I2)=WHT(I1)
      I1=I1+1
      I2=I2-1
 2000 IC=IC+1
C     N.B FOR NPT ODD, THE LAST (I.E. MIDDLE) TERM IS EVALUATED TWICE.
      RETURN
 9999 WRITE(6,610)  NPT
  610 FORMAT('0 * * * WARNING.  GAUSS-LEGENDRE REQUESTED WITH NPT =',I6)
C     REPLACE WITH SINGLE-POINT AT (A+B)/2 * (B-A)
      NPT=1
 9998 XPT(1)=T2
      WHT(1)=2.D0*T1
      RETURN
      END
c 
c Compute the set of associated Legendre polynomials P_lm
c for l=0,1,...,lmax, and m=0,1,...,l. First the standard
c polynomials
c
c   P^m_l(x) = (1/2^l l!)(1-x^2)^(m/2) (d^(l+m)/d x^(l+m))(x^2 -1)^l
c
c are computed, and then multiplied by
c
c  (-1)^m sqrt[(2l+1)(l-m)!/2(l+m)!]/sqrt(2Pi)
c
c to get the P_lm polynomials....
c
        subroutine xplm(p,x,lmax)
        implicit real*8 (a-h,o-z)
        dimension p(0:50,0:50)
        common/factorial/ fact(0:40)
c inverse of dsqrt(2Pi)
        data twopinv /0.3989422804014d0/
c
c starting value
c
        p(0,0) = 1.d0
        u = dsqrt(1-x*x)
c
c compute the diagonal elements
c
        do l=1,lmax
         p(l,l) = (2*l-1)*p(l-1,l-1)*u
        end do
c
c compute P_lm along the columns with fixed m
c
        do m = 0,lmax-1
        do l = m,lmax-1
         if((l-1).lt.m) then
           pp = 0
         else
           pp = p(l-1,m)
         endif
         p(l+1,m) = ((2*l+1)*x*p(l,m)-(l+m)*pp)/(l-m+1)
        end do 
        end do
c
c Renormalize values...
c
c       do l=0,lmax
c       mm = 1
c       do m=0,l
c        dnorm = fact(l-m)*(2*l+1)/(2*fact(l+m))
c        p(l,m) = mm*twopinv*dsqrt(dnorm)*p(l,m)
c        mm = -mm
c       end do
c       end do
c
        return
        end
c
c compute the matrix of N!
c
        subroutine fct(nmax)
        implicit real*8 (a-h,o-z)
        common/factorial/ f(0:40)
c       
        f(0) = 1.d0
        do i=1,nmax
         f(i) = f(i-1)*i
        end do
        return
        end
      FUNCTION PARITY(I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARITY=1.D0
      IF((I/2)*2-I.NE.0) PARITY=-1.D0
      RETURN
      END
      FUNCTION ZBES(K)
C *** ROUTINE REQUIRED BY GASLEG (GAUSS LEGENDRE PT/WT GENERATOR)
C *** TAKEN FROM AD VAN DER AVOIRD'S N2-N2 CODE  (SG 11/7/91)
      DOUBLE PRECISION PI,ZBES,B,BB,B3,B5,B7
      DATA PI/3.14159 26535 89793 D0/
      B=(DBLE(K)-0.25D0)*PI
      BB=1.0D0/(8.0D0*B)
      B3=BB*BB*BB
      B5=B3*BB*BB
      B7=B5*BB*BB
      ZBES=B+BB-(124.0D0/3.0D0)*B3+(120928.0D0/15.0D0)*B5-(401743168.0D0
     1/105.0D0)*B7
      RETURN
      END
	  
